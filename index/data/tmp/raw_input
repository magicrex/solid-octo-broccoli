http://www.cplusplus.com/reference/array/array/index.htmlarrayarray - C++ Reference   (function() {     var useSSL = 'https:' == document.location.protocol;     var src = (useSSL ? 'https:' : 'http:') +         '//www.googletagservices.com/tag/js/gpt.js';     document.write('');   })(); Search:   Reference <array> array class template <array> std::array template < class T, size_t N > class array;Array class Arrays are fixed-size sequence containers: they hold a specific number of elements ordered in a strict linear sequence.    Internally, an array does not keep any data other than the elements it contains (not even its size, which is a template parameter, fixed on compile time). It is as efficient in terms of storage size as an ordinary array declared with the language's bracket syntax ([]). This class merely adds a layer of member and global functions to it, so that arrays can be used as standard containers.    Unlike the other standard containers, arrays have a fixed size and do not manage the allocation of its elements through an allocator: they are an aggregate type encapsulating a fixed-size array of elements. Therefore, they cannot be expanded or contracted dynamically (see vector for a similar container that can be expanded).    Zero-sized arrays are valid, but they should not be dereferenced (members front, back, and data).    Unlike with the other containers in the Standard Library, swapping two array containers is a linear operation that involves swapping all the elements in the ranges individually, which generally is a considerably less efficient operation. On the other side, this allows the iterators to elements in both containers to keep their original container association.    Another unique feature of array containers is that they can be treated as tuple objects: The <array> header overloads the get function to access the elements of the array as if it was a tuple, as well as specialized tuple_size and tuple_element types.    Container properties Sequence Elements in sequence containers are ordered in a strict linear sequence. Individual elements are accessed by their position in this sequence. Contiguous storage The elements are stored in contiguous memory locations, allowing constant time random access to elements. Pointers to an element can be offset to access other elements. Fixed-size aggregate The container uses implicit constructors and destructors to allocate the required space statically. Its size is compile-time constant. No memory or time overhead.   Template parameters T Type of the elements contained.  Aliased as member type array::value_type. N Size of the array, in terms of number of elements. In the reference for the array member functions, these same names are assumed for the template parameters.    Member types The following aliases are member types of array. They are widely used as parameter and return types by member functions:    member typedefinitionnotes value_typeThe first template parameter (T) referencevalue_type& const_referenceconst value_type& pointervalue_type* const_pointerconst value_type* iteratora random access iterator to value_typeconvertible to const_iterator const_iteratora random access iterator to const value_type reverse_iteratorreverse_iterator<iterator> const_reverse_iteratorreverse_iterator<const_iterator> size_typesize_tunsigned integral type difference_typeptrdiff_tsigned integral type   Member functions Iterators beginReturn iterator to beginning (public member function)endReturn iterator to end (public member function)rbeginReturn reverse iterator to reverse beginning (public member function)rendReturn reverse iterator to reverse end (public member function)cbeginReturn const_iterator to beginning (public member function)cendReturn const_iterator to end (public member function)crbeginReturn const_reverse_iterator to reverse beginning (public member function)crendReturn const_reverse_iterator to reverse end (public member function)   Capacity sizeReturn size (public member function)max_sizeReturn maximum size (public member function)emptyTest whether array is empty (public member function)   Element access operator[]Access element (public member function)atAccess element (public member function)frontAccess first element (public member function)backAccess last element (public member function)dataGet pointer to data (public member function)   Modifiers fillFill array with value (public member function)swapSwap content (public member function)   Non-member function overloads get (array)Get element (tuple interface) (function template)relational operators (array)Relational operators for array (function template)   Non-member class specializations tuple_element<array>Tuple element type for array (class template specialization)tuple_size<array>Tuple size traits for array (class template specialization) C++ Information Tutorials Reference Articles Forum Reference C library: <cassert> (assert.h) <cctype> (ctype.h) <cerrno> (errno.h) <cfenv> (fenv.h) <cfloat> (float.h) <cinttypes> (inttypes.h) <ciso646> (iso646.h) <climits> (limits.h) <clocale> (locale.h) <cmath> (math.h) <csetjmp> (setjmp.h) <csignal> (signal.h) <cstdarg> (stdarg.h) <cstdbool> (stdbool.h) <cstddef> (stddef.h) <cstdint> (stdint.h) <cstdio> (stdio.h) <cstdlib> (stdlib.h) <cstring> (string.h) <ctgmath> (tgmath.h) <ctime> (time.h) <cuchar> (uchar.h) <cwchar> (wchar.h) <cwctype> (wctype.h) Containers: <array> <deque> <forward_list> <list> <map> <queue> <set> <stack> <unordered_map> <unordered_set> <vector> Input/Output: <fstream> <iomanip> <ios> <iosfwd> <iostream> <istream> <ostream> <sstream> <streambuf> Multi-threading: <atomic> <condition_variable> <future> <mutex> <thread> Other: <algorithm> <bitset> <chrono> <codecvt> <complex> <exception> <functional> <initializer_list> <iterator> <limits> <locale> <memory> <new> <numeric> <random> <ratio> <regex> <stdexcept> <string> <system_error> <tuple> <typeindex> <typeinfo> <type_traits> <utility> <valarray> <array> array array array::array member functions: array::at array::back array::begin array::cbegin array::cend array::crbegin array::crend array::data array::empty array::end array::fill array::front array::max_size array::operator[] array::rbegin array::rend array::size array::swap non-member overloads: get (array) relational operators (array) non-member specializations: tuple_element<array> tuple_size<array> 			 	Home page | Privacy policy  cplusplus.com, 2000-2017 - All rights reserved - v3.1 Spotted an error? contact us (function(){   // mini cookie-consent code (c) Juan Soulie, 2016   var s ='consent=cookie';   var e = document.createElement('div');   e.innerHTML = 'This website uses cookies. By continuing, you give permission to deploy cookies, as detailed in our privacy policy. ok';   if (document.cookie.indexOf(s)!==-1) return;   var b = document.getElementsByTagName('body')[0];   b.insertBefore(e,b.firstChild);   var x = function() { document.cookie = s+'; path=/'; e.parentNode.removeChild(e); };   e.addEventListener('click',x);   document.addEventListener('scroll',x); })(); 
http://www.cplusplus.com/reference/vector/vector/index.htmlvector vector - C++ Reference   (function() {     var useSSL = 'https:' == document.location.protocol;     var src = (useSSL ? 'https:' : 'http:') +         '//www.googletagservices.com/tag/js/gpt.js';     document.write('');   })(); Search:   Reference <vector> vector class template <vector> std::vector template < class T, class Alloc = allocator<T> > class vector; // generic templateVector Vectors are sequence containers representing arrays that can change in size.    Just like arrays, vectors use contiguous storage locations for their elements, which means that their elements can also be accessed using offsets on regular pointers to its elements, and just as efficiently as in arrays. But unlike arrays, their  size can change dynamically, with their storage being handled automatically by the container.    Internally, vectors use a dynamically allocated array to store their elements. This array may need to be reallocated in order to grow in size when new elements are inserted, which implies allocating a new array and moving all elements to it. This is a relatively expensive task in terms of processing time, and thus, vectors do not reallocate each time an element is added to the container.    Instead, vector containers may allocate some extra storage to accommodate for possible growth, and thus the container may have an actual capacity greater than the storage strictly needed to contain its elements (i.e., its size). Libraries can implement different strategies for growth to balance between memory usage and reallocations, but in any case, reallocations should only happen at logarithmically growing intervals of size so that the insertion of individual elements at the end of the vector can be provided with amortized constant time complexity (see push_back).    Therefore, compared to arrays, vectors consume more memory in exchange for the ability to manage storage and grow dynamically in an efficient way.    Compared to the other dynamic sequence containers (deques, lists and forward_lists), vectors are very efficient accessing its elements (just like arrays) and relatively efficient adding or removing elements from its end. For operations that involve inserting or removing elements at positions other than the end, they perform worse than the others, and have less consistent iterators and references than lists and forward_lists.    Container properties Sequence Elements in sequence containers are ordered in a strict linear sequence. Individual elements are accessed by their position in this sequence. Dynamic array Allows direct access to any element in the sequence, even through pointer arithmetics, and provides relatively fast addition/removal of elements at the end of the sequence. Allocator-aware The container uses an allocator object to dynamically handle its storage needs.   Template parameters T Type of the elements.  Only if T is guaranteed to not throw while moving, implementations can optimize to move elements instead of copying them during reallocations.  Aliased as member type vector::value_type. Alloc Type of the allocator object used to define the storage allocation model. By default, the allocator class template is used, which defines the simplest memory allocation model and is value-independent.  Aliased as member type vector::allocator_type.   Member types member typedefinitionnotes value_typeThe first template parameter (T) allocator_typeThe second template parameter (Alloc)defaults to: allocator<value_type> referenceallocator_type::referencefor the default allocator: value_type& const_referenceallocator_type::const_referencefor the default allocator: const value_type& pointerallocator_type::pointerfor the default allocator: value_type* const_pointerallocator_type::const_pointerfor the default allocator: const value_type* iteratora random access iterator to value_typeconvertible to const_iterator const_iteratora random access iterator to const value_type reverse_iteratorreverse_iterator<iterator> const_reverse_iteratorreverse_iterator<const_iterator> difference_typea signed integral type, identical to: iterator_traits<iterator>::difference_typeusually the same as ptrdiff_t size_typean unsigned integral type that can represent any non-negative value of difference_typeusually the same as size_t member typedefinitionnotes value_typeThe first template parameter (T) allocator_typeThe second template parameter (Alloc)defaults to: allocator<value_type> referencevalue_type& const_referenceconst value_type& pointerallocator_traits<allocator_type>::pointerfor the default allocator: value_type* const_pointerallocator_traits<allocator_type>::const_pointerfor the default allocator: const value_type* iteratora random access iterator to value_typeconvertible to const_iterator const_iteratora random access iterator to const value_type reverse_iteratorreverse_iterator<iterator> const_reverse_iteratorreverse_iterator<const_iterator> difference_typea signed integral type, identical to:  iterator_traits<iterator>::difference_typeusually the same as ptrdiff_t size_typean unsigned integral type that can represent any non-negative value of difference_typeusually the same as size_t   Member functions (constructor)Construct vector (public member function)(destructor)Vector destructor (public member function)operator=Assign content (public member function)   Iterators:  beginReturn iterator to beginning (public member function)endReturn iterator to end (public member function)rbeginReturn reverse iterator to reverse beginning (public member function)rendReturn reverse iterator to reverse end (public member function)cbegin Return const_iterator to beginning (public member function)cend Return const_iterator to end (public member function)crbegin Return const_reverse_iterator to reverse beginning (public member function)crend Return const_reverse_iterator to reverse end (public member function)   Capacity:  sizeReturn size (public member function)max_sizeReturn maximum size (public member function)resizeChange size (public member function)capacityReturn size of allocated storage capacity (public member function)emptyTest whether vector is empty (public member function)reserveRequest a change in capacity (public member function)shrink_to_fit Shrink to fit (public member function)   Element access:  operator[]Access element (public member function)atAccess element (public member function)frontAccess first element (public member function)backAccess last element (public member function)data Access data (public member function)   Modifiers:  assignAssign vector content (public member function)push_backAdd element at the end (public member function)pop_backDelete last element (public member function)insertInsert elements (public member function)eraseErase elements (public member function)swapSwap content (public member function)clearClear content (public member function)emplace Construct and insert element (public member function)emplace_back Construct and insert element at the end (public member function)   Allocator:  get_allocatorGet allocator (public member function)   Non-member function overloads relational operatorsRelational operators for vector (function template)swapExchange contents of vectors (function template)   Template specializations vector<bool>Vector of bool (class template specialization) C++ Information Tutorials Reference Articles Forum Reference C library: <cassert> (assert.h) <cctype> (ctype.h) <cerrno> (errno.h) <cfenv> (fenv.h) <cfloat> (float.h) <cinttypes> (inttypes.h) <ciso646> (iso646.h) <climits> (limits.h) <clocale> (locale.h) <cmath> (math.h) <csetjmp> (setjmp.h) <csignal> (signal.h) <cstdarg> (stdarg.h) <cstdbool> (stdbool.h) <cstddef> (stddef.h) <cstdint> (stdint.h) <cstdio> (stdio.h) <cstdlib> (stdlib.h) <cstring> (string.h) <ctgmath> (tgmath.h) <ctime> (time.h) <cuchar> (uchar.h) <cwchar> (wchar.h) <cwctype> (wctype.h) Containers: <array> <deque> <forward_list> <list> <map> <queue> <set> <stack> <unordered_map> <unordered_set> <vector> Input/Output: <fstream> <iomanip> <ios> <iosfwd> <iostream> <istream> <ostream> <sstream> <streambuf> Multi-threading: <atomic> <condition_variable> <future> <mutex> <thread> Other: <algorithm> <bitset> <chrono> <codecvt> <complex> <exception> <functional> <initializer_list> <iterator> <limits> <locale> <memory> <new> <numeric> <random> <ratio> <regex> <stdexcept> <string> <system_error> <tuple> <typeindex> <typeinfo> <type_traits> <utility> <valarray> <vector> vector vector<bool> vector vector::vector vector::~vector member functions: vector::assign vector::at vector::back vector::begin vector::capacity vector::cbegin vector::cend vector::clear vector::crbegin vector::crend vector::data vector::emplace vector::emplace_back vector::empty vector::end vector::erase vector::front vector::get_allocator vector::insert vector::max_size vector::operator= vector::operator[] vector::pop_back vector::push_back vector::rbegin vector::rend vector::reserve vector::resize vector::shrink_to_fit vector::size vector::swap non-member overloads: relational operators (vector) swap (vector) 			 	Home page | Privacy policy  cplusplus.com, 2000-2017 - All rights reserved - v3.1 Spotted an error? contact us (function(){   // mini cookie-consent code (c) Juan Soulie, 2016   var s ='consent=cookie';   var e = document.createElement('div');   e.innerHTML = 'This website uses cookies. By continuing, you give permission to deploy cookies, as detailed in our privacy policy. ok';   if (document.cookie.indexOf(s)!==-1) return;   var b = document.getElementsByTagName('body')[0];   b.insertBefore(e,b.firstChild);   var x = function() { document.cookie = s+'; path=/'; e.parentNode.removeChild(e); };   e.addEventListener('click',x);   document.addEventListener('scroll',x); })(); 
http://www.cplusplus.com/reference/deque/deque/index.htmldeque deque - C++ Reference   (function() {     var useSSL = 'https:' == document.location.protocol;     var src = (useSSL ? 'https:' : 'http:') +         '//www.googletagservices.com/tag/js/gpt.js';     document.write('');   })(); Search:   Reference <deque> deque class template <deque> std::deque template < class T, class Alloc = allocator<T> > class deque;Double ended queue deque (usually pronounced like "deck") is an irregular acronym of double-ended queue. Double-ended queues are sequence containers with dynamic sizes that can be expanded or contracted on both ends (either its front or its back).    Specific libraries may implement deques in different ways, generally as some form of dynamic array. But in any case, they allow for the individual elements to be accessed directly through random access iterators, with storage handled automatically by expanding and contracting the container as needed.    Therefore, they provide a functionality similar to vectors, but with efficient insertion and deletion of elements also at the beginning of the sequence, and not only at its end. But, unlike vectors, deques are not guaranteed to store all its elements in contiguous storage locations: accessing elements in a deque by offsetting a pointer to another element causes undefined behavior.    Both vectors and deques provide a very similar interface and can be used for similar purposes, but internally both work in quite different ways: While vectors use a single array that needs to be occasionally reallocated for growth, the elements of a deque can be scattered in different chunks of storage, with the container keeping the necessary information internally to provide direct access to any of its elements in constant time and with a uniform sequential interface (through iterators). Therefore, deques are a little more complex internally than vectors, but this allows them to grow more efficiently under certain circumstances, especially with very long sequences, where reallocations become more expensive.    For operations that involve frequent insertion or removals of elements at positions other than the beginning or the end, deques perform worse and have less consistent iterators and references than lists and forward lists.    Container properties Sequence Elements in sequence containers are ordered in a strict linear sequence. Individual elements are accessed by their position in this sequence. Dynamic array Generally implemented as a dynamic array, it allows direct access to any element in the sequence and provides relatively fast addition/removal of elements at the beginning or the end of the sequence. Allocator-aware The container uses an allocator object to dynamically handle its storage needs.   Template parameters T Type of the elements.  Aliased as member type deque::value_type. Alloc Type of the allocator object used to define the storage allocation model. By default, the allocator class template is used, which defines the simplest memory allocation model and is value-independent.  Aliased as member type deque::allocator_type.   Member types member typedefinitionnotes value_typeThe first template parameter (T) allocator_typeThe second template parameter (Alloc)defaults to: allocator<value_type> referenceallocator_type::referencefor the default allocator: value_type& const_referenceallocator_type::const_referencefor the default allocator: const value_type& pointerallocator_type::pointerfor the default allocator: value_type* const_pointerallocator_type::const_pointerfor the default allocator: const value_type* iteratora random access iterator to value_typeconvertible to const_iterator const_iteratora random access iterator to const value_type reverse_iteratorreverse_iterator<iterator> const_reverse_iteratorreverse_iterator<const_iterator> difference_typea signed integral type, identical to: iterator_traits<iterator>::difference_typeusually the same as ptrdiff_t size_typean unsigned integral type that can represent any non-negative value of difference_typeusually the same as size_t member typedefinitionnotes value_typeThe first template parameter (T) allocator_typeThe second template parameter (Alloc)defaults to: allocator<value_type> referencevalue_type& const_referenceconst value_type& pointerallocator_traits<allocator_type>::pointerfor the default allocator: value_type* const_pointerallocator_traits<allocator_type>::const_pointerfor the default allocator: const value_type* iteratora random access iterator to value_typeconvertible to const_iterator const_iteratora random access iterator to const value_type reverse_iteratorreverse_iterator<iterator> const_reverse_iteratorreverse_iterator<const_iterator> difference_typea signed integral type, identical to:  iterator_traits<iterator>::difference_typeusually the same as ptrdiff_t size_typean unsigned integral type that can represent any non-negative value of difference_typeusually the same as size_t   Member functions (constructor)Construct deque container (public member function)(destructor)Deque destructor (public member function)operator=Assign content (public member function)   Iterators:  beginReturn iterator to beginning (public member function)endReturn iterator to end (public member function)rbeginReturn reverse iterator to reverse beginning (public member function)rendReturn reverse iterator to reverse end (public member function)cbegin Return const_iterator to beginning (public member function)cend Return const_iterator to end (public member function)crbegin Return const_reverse_iterator to reverse beginning (public member function)crend Return const_reverse_iterator to reverse end (public member function)   Capacity:  sizeReturn size (public member function)max_sizeReturn maximum size (public member function)resizeChange size (public member function)emptyTest whether container is empty (public member function)shrink_to_fit Shrink to fit (public member function)   Element access:  operator[]Access element (public member function)atAccess element (public member function)frontAccess first element (public member function)backAccess last element (public member function)   Modifiers:  assignAssign container content (public member function)push_backAdd element at the end (public member function)push_frontInsert element at beginning (public member function)pop_backDelete last element (public member function)pop_frontDelete first element (public member function)insertInsert elements (public member function)eraseErase elements (public member function)swapSwap content (public member function)clearClear content (public member function)emplace Construct and insert element (public member function)emplace_front Construct and insert element at beginning (public member function)emplace_back Construct and insert element at the end (public member function)   Allocator:  get_allocatorGet allocator (public member function)   Non-member functions overloads relational operatorsRelational operators for deque (function)swapExchanges the contents of two deque containers (function template) C++ Information Tutorials Reference Articles Forum Reference C library: <cassert> (assert.h) <cctype> (ctype.h) <cerrno> (errno.h) <cfenv> (fenv.h) <cfloat> (float.h) <cinttypes> (inttypes.h) <ciso646> (iso646.h) <climits> (limits.h) <clocale> (locale.h) <cmath> (math.h) <csetjmp> (setjmp.h) <csignal> (signal.h) <cstdarg> (stdarg.h) <cstdbool> (stdbool.h) <cstddef> (stddef.h) <cstdint> (stdint.h) <cstdio> (stdio.h) <cstdlib> (stdlib.h) <cstring> (string.h) <ctgmath> (tgmath.h) <ctime> (time.h) <cuchar> (uchar.h) <cwchar> (wchar.h) <cwctype> (wctype.h) Containers: <array> <deque> <forward_list> <list> <map> <queue> <set> <stack> <unordered_map> <unordered_set> <vector> Input/Output: <fstream> <iomanip> <ios> <iosfwd> <iostream> <istream> <ostream> <sstream> <streambuf> Multi-threading: <atomic> <condition_variable> <future> <mutex> <thread> Other: <algorithm> <bitset> <chrono> <codecvt> <complex> <exception> <functional> <initializer_list> <iterator> <limits> <locale> <memory> <new> <numeric> <random> <ratio> <regex> <stdexcept> <string> <system_error> <tuple> <typeindex> <typeinfo> <type_traits> <utility> <valarray> <deque> deque deque deque::deque deque::~deque member functions: deque::assign deque::at deque::back deque::begin deque::cbegin deque::cend deque::clear deque::crbegin deque::crend deque::emplace deque::emplace_back deque::emplace_front deque::empty deque::end deque::erase deque::front deque::get_allocator deque::insert deque::max_size deque::operator= deque::operator[] deque::pop_back deque::pop_front deque::push_back deque::push_front deque::rbegin deque::rend deque::resize deque::shrink_to_fit deque::size deque::swap non-member overloads: relational operators (deque) swap (deque) 			 	Home page | Privacy policy  cplusplus.com, 2000-2017 - All rights reserved - v3.1 Spotted an error? contact us (function(){   // mini cookie-consent code (c) Juan Soulie, 2016   var s ='consent=cookie';   var e = document.createElement('div');   e.innerHTML = 'This website uses cookies. By continuing, you give permission to deploy cookies, as detailed in our privacy policy. ok';   if (document.cookie.indexOf(s)!==-1) return;   var b = document.getElementsByTagName('body')[0];   b.insertBefore(e,b.firstChild);   var x = function() { document.cookie = s+'; path=/'; e.parentNode.removeChild(e); };   e.addEventListener('click',x);   document.addEventListener('scroll',x); })(); 
http://www.cplusplus.com/reference/forward_list/forward_list/index.htmlforward_list forward_list - C++ Reference   (function() {     var useSSL = 'https:' == document.location.protocol;     var src = (useSSL ? 'https:' : 'http:') +         '//www.googletagservices.com/tag/js/gpt.js';     document.write('');   })(); Search:   Reference <forward_list> forward_list class template <forward_list> std::forward_list template < class T, class Alloc = allocator<T> > class forward_list;Forward list Forward lists are sequence containers that allow constant time insert and erase operations anywhere within the sequence.    Forward lists are implemented as singly-linked lists; Singly linked lists can store each of the elements they contain in different and unrelated storage locations. The ordering is kept by the association to each element of a link to the next element in the sequence.    The main design difference between a forward_list container and a list container is that the first keeps internally only a link to the next element, while the latter keeps two links per element: one pointing to the next element and one to the preceding one, allowing efficient iteration in both directions, but consuming additional storage per element and with a slight higher time overhead inserting and removing elements. forward_list objects are thus more efficient than list objects, although they can only be iterated forwards.     Compared to other base standard sequence containers (array, vector and deque), forward_list perform generally better in inserting, extracting and moving elements in any position within the container, and therefore also in algorithms that make intensive use of these, like sorting algorithms.    The main drawback of forward_lists and lists compared to these other sequence containers is that they lack direct access to the elements by their position; For example, to access the sixth element in a forward_list one has to iterate from the beginning to that position, which takes linear time in the distance between these. They also consume some extra memory to keep the linking information associated to each element (which may be an important factor for large lists of small-sized elements).    The forward_list class template has been designed with efficiency in mind: By design, it is as efficient as a simple handwritten C-style singly-linked list, and in fact is the only standard container to deliberately lack a size member function for efficiency considerations: due to its nature as a linked list, having a size member that takes constant time would require it to keep an internal counter for its size (as list does). This would consume some extra storage and make insertion and removal operations slightly less efficient. To obtain the size of a forward_list object, you can use the distance algorithm with its begin and end, which is an operation that takes linear time.    Container properties Sequence Elements in sequence containers are ordered in a strict linear sequence. Individual elements are accessed by their position in this sequence. Linked list Each element keeps information on how to locate the next element, allowing constant time insert and erase operations after a specific element (even of entire ranges), but no direct random access. Allocator-aware The container uses an allocator object to dynamically handle its storage needs.   Template parameters T Type of the elements.  Aliased as member type forward_list::value_type. Alloc Type of the allocator object used to define the storage allocation model. By default, the allocator class template is used, which defines the simplest memory allocation model and is value-independent.  Aliased as member type forward_list::allocator_type.   Member types member typedefinitionnotes value_typeThe first template parameter (T) allocator_typeThe second template parameter (Alloc)defaults to: allocator<value_type> referencevalue_type& const_referenceconst value_type& pointerallocator_traits<allocator_type>::pointerfor the default allocator: value_type* const_pointerallocator_traits<allocator_type>::const_pointerfor the default allocator: const value_type* iteratora forward iterator to value_typeconvertible to const_iterator const_iteratora forward iterator to const value_type difference_typea signed integral type, identical to: iterator_traits<iterator>::difference_typeusually the same as ptrdiff_t size_typean unsigned integral type that can represent any non-negative value of difference_typeusually the same as size_t   Member functions (constructor)Construct forward_list object (public member function)(destructor)Destroy forward_list object (public member function)operator=Assign content (public member function)   Iterators before_beginReturn iterator to before beginning (public member function)beginReturn iterator to beginning (public member type)endReturn iterator to end (public member function)cbefore_beginReturn const_iterator to before beginning (public member function)cbeginReturn const_iterator to beginning (public member function)cendReturn const_iterator to end (public member function)   Capacity emptyTest whether array is empty (public member function)max_sizeReturn maximum size (public member function)   Element access frontAccess first element (public member function)   Modifiers assignAssign content (public member function)emplace_frontConstruct and insert element at beginning (public member function)push_frontInsert element at beginning (public member function)pop_frontDelete first element (public member function)emplace_afterConstruct and insert element (public member function)insert_afterInsert elements (public member function)erase_afterErase elements (public member function)swapSwap content (public member function)resizeChange size (public member function)clearClear content (public member function)   Operations splice_afterTransfer elements from another forward_list (public member function)removeRemove elements with specific value (public member function)remove_ifRemove elements fulfilling condition (public member function template)uniqueRemove duplicate values (public member function)mergeMerge sorted lists (public member function)sortSort elements in container (public member function)reverseReverse the order of elements (public member function)   Observers get_allocatorGet allocator (public member function)   Non-member function overloads relational operators (forward_list)Relational operators for forward_list (function template)swap (forward_list)Exchanges the contents of two forward_list containers (function template) C++ Information Tutorials Reference Articles Forum Reference C library: <cassert> (assert.h) <cctype> (ctype.h) <cerrno> (errno.h) <cfenv> (fenv.h) <cfloat> (float.h) <cinttypes> (inttypes.h) <ciso646> (iso646.h) <climits> (limits.h) <clocale> (locale.h) <cmath> (math.h) <csetjmp> (setjmp.h) <csignal> (signal.h) <cstdarg> (stdarg.h) <cstdbool> (stdbool.h) <cstddef> (stddef.h) <cstdint> (stdint.h) <cstdio> (stdio.h) <cstdlib> (stdlib.h) <cstring> (string.h) <ctgmath> (tgmath.h) <ctime> (time.h) <cuchar> (uchar.h) <cwchar> (wchar.h) <cwctype> (wctype.h) Containers: <array> <deque> <forward_list> <list> <map> <queue> <set> <stack> <unordered_map> <unordered_set> <vector> Input/Output: <fstream> <iomanip> <ios> <iosfwd> <iostream> <istream> <ostream> <sstream> <streambuf> Multi-threading: <atomic> <condition_variable> <future> <mutex> <thread> Other: <algorithm> <bitset> <chrono> <codecvt> <complex> <exception> <functional> <initializer_list> <iterator> <limits> <locale> <memory> <new> <numeric> <random> <ratio> <regex> <stdexcept> <string> <system_error> <tuple> <typeindex> <typeinfo> <type_traits> <utility> <valarray> <forward_list> forward_list forward_list forward_list::forward_list forward_list::~forward_list member functions: forward_list::assign  forward_list::before_begin forward_list::begin forward_list::cbefore_begin forward_list::cbegin forward_list::cend forward_list::clear forward_list::emplace_after forward_list::emplace_front forward_list::empty forward_list::end forward_list::erase_after forward_list::front forward_list::get_allocator forward_list::insert_after forward_list::max_size forward_list::merge forward_list::operator= forward_list::pop_front forward_list::push_front forward_list::remove forward_list::remove_if forward_list::resize forward_list::reverse forward_list::sort forward_list::splice_after forward_list::swap forward_list::unique non-member overloads: relational operators (forward_list) swap (forward_list) 			 	Home page | Privacy policy  cplusplus.com, 2000-2017 - All rights reserved - v3.1 Spotted an error? contact us (function(){   // mini cookie-consent code (c) Juan Soulie, 2016   var s ='consent=cookie';   var e = document.createElement('div');   e.innerHTML = 'This website uses cookies. By continuing, you give permission to deploy cookies, as detailed in our privacy policy. ok';   if (document.cookie.indexOf(s)!==-1) return;   var b = document.getElementsByTagName('body')[0];   b.insertBefore(e,b.firstChild);   var x = function() { document.cookie = s+'; path=/'; e.parentNode.removeChild(e); };   e.addEventListener('click',x);   document.addEventListener('scroll',x); })(); 
http://www.cplusplus.com/reference/list/list/index.htmllist list - C++ Reference   (function() {     var useSSL = 'https:' == document.location.protocol;     var src = (useSSL ? 'https:' : 'http:') +         '//www.googletagservices.com/tag/js/gpt.js';     document.write('');   })(); Search:   Reference <list> list class template <list> std::list template < class T, class Alloc = allocator<T> > class list;List Lists are sequence containers that allow constant time insert and erase operations anywhere within the sequence, and iteration in both directions.    List containers are implemented as doubly-linked lists; Doubly linked lists can store each of the elements they contain in different and unrelated storage locations. The ordering is kept internally by the association to each element of a link to the element preceding it and a link to the element following it.    They are very similar to forward_list: The main difference being that forward_list objects are single-linked lists, and thus they can only be iterated forwards, in exchange for being somewhat smaller and more efficient.    Compared to other base standard sequence containers (array, vector and deque), lists perform generally better in inserting, extracting and moving elements in any position within the container for which an iterator has already been obtained, and therefore also in algorithms that make intensive use of these, like sorting algorithms.    The main drawback of lists and forward_lists compared to these other sequence containers is that they lack direct access to the elements by their position; For example, to access the sixth element in a list, one has to iterate from a known position (like the beginning or the end) to that position, which takes linear time in the distance between these. They also consume some extra memory to keep the linking information associated to each element (which may be an important factor for large lists of small-sized elements).    Container properties Sequence Elements in sequence containers are ordered in a strict linear sequence. Individual elements are accessed by their position in this sequence. Doubly-linked list Each element keeps information on how to locate the next and the previous elements, allowing constant time insert and erase operations before or after a specific element (even of entire ranges), but no direct random access. Allocator-aware The container uses an allocator object to dynamically handle its storage needs.   Template parameters T Type of the elements.  Aliased as member type list::value_type. Alloc Type of the allocator object used to define the storage allocation model. By default, the allocator class template is used, which defines the simplest memory allocation model and is value-independent.  Aliased as member type list::allocator_type.   Member types member typedefinitionnotes value_typeThe first template parameter (T) allocator_typeThe second template parameter (Alloc)defaults to: allocator<value_type> referenceallocator_type::referencefor the default allocator: value_type& const_referenceallocator_type::const_referencefor the default allocator: const value_type& pointerallocator_type::pointerfor the default allocator: value_type* const_pointerallocator_type::const_pointerfor the default allocator: const value_type* iteratora bidirectional iterator to value_typeconvertible to const_iterator const_iteratora bidirectional iterator to const value_type reverse_iteratorreverse_iterator<iterator> const_reverse_iteratorreverse_iterator<const_iterator> difference_typea signed integral type, identical to: iterator_traits<iterator>::difference_typeusually the same as ptrdiff_t size_typean unsigned integral type that can represent any non-negative value of difference_typeusually the same as size_t member typedefinitionnotes value_typeThe first template parameter (T) allocator_typeThe second template parameter (Alloc)defaults to: allocator<value_type> referencevalue_type& const_referenceconst value_type& pointerallocator_traits<allocator_type>::pointerfor the default allocator: value_type* const_pointerallocator_traits<allocator_type>::const_pointerfor the default allocator: const value_type* iteratora bidirectional iterator to value_typeconvertible to const_iterator const_iteratora bidirectional iterator to const value_type reverse_iteratorreverse_iterator<iterator> const_reverse_iteratorreverse_iterator<const_iterator> difference_typea signed integral type, identical to:  iterator_traits<iterator>::difference_typeusually the same as ptrdiff_t size_typean unsigned integral type that can represent any non-negative value of difference_typeusually the same as size_t     Member functions (constructor)Construct list (public member function)(destructor)List destructor (public member function)operator=Assign content (public member function)   Iterators:  beginReturn iterator to beginning (public member function)endReturn iterator to end (public member function)rbeginReturn reverse iterator to reverse beginning (public member function)rendReturn reverse iterator to reverse end (public member function)cbegin Return const_iterator to beginning (public member function)cend Return const_iterator to end (public member function)crbegin Return const_reverse_iterator to reverse beginning (public member function)crend Return const_reverse_iterator to reverse end (public member function)   Capacity:  emptyTest whether container is empty (public member function)sizeReturn size (public member function)max_sizeReturn maximum size (public member function)   Element access:  frontAccess first element (public member function)backAccess last element (public member function)   Modifiers:  assignAssign new content to container (public member function)emplace_front Construct and insert element at beginning (public member function)push_frontInsert element at beginning (public member function)pop_frontDelete first element (public member function)emplace_back Construct and insert element at the end (public member function)push_backAdd element at the end (public member function)pop_backDelete last element (public member function)emplace Construct and insert element (public member function)insertInsert elements (public member function)eraseErase elements (public member function)swapSwap content (public member function)resizeChange size (public member function)clearClear content (public member function)   Operations:  spliceTransfer elements from list to list (public member function)removeRemove elements with specific value (public member function)remove_ifRemove elements fulfilling condition (public member function template)uniqueRemove duplicate values (public member function)mergeMerge sorted lists (public member function)sortSort elements in container (public member function)reverseReverse the order of elements (public member function)   Observers:  get_allocatorGet allocator (public member function)   Non-member function overloads relational operators (list)Relational operators for list (function)swap (list)Exchanges the contents of two lists (function template) C++ Information Tutorials Reference Articles Forum Reference C library: <cassert> (assert.h) <cctype> (ctype.h) <cerrno> (errno.h) <cfenv> (fenv.h) <cfloat> (float.h) <cinttypes> (inttypes.h) <ciso646> (iso646.h) <climits> (limits.h) <clocale> (locale.h) <cmath> (math.h) <csetjmp> (setjmp.h) <csignal> (signal.h) <cstdarg> (stdarg.h) <cstdbool> (stdbool.h) <cstddef> (stddef.h) <cstdint> (stdint.h) <cstdio> (stdio.h) <cstdlib> (stdlib.h) <cstring> (string.h) <ctgmath> (tgmath.h) <ctime> (time.h) <cuchar> (uchar.h) <cwchar> (wchar.h) <cwctype> (wctype.h) Containers: <array> <deque> <forward_list> <list> <map> <queue> <set> <stack> <unordered_map> <unordered_set> <vector> Input/Output: <fstream> <iomanip> <ios> <iosfwd> <iostream> <istream> <ostream> <sstream> <streambuf> Multi-threading: <atomic> <condition_variable> <future> <mutex> <thread> Other: <algorithm> <bitset> <chrono> <codecvt> <complex> <exception> <functional> <initializer_list> <iterator> <limits> <locale> <memory> <new> <numeric> <random> <ratio> <regex> <stdexcept> <string> <system_error> <tuple> <typeindex> <typeinfo> <type_traits> <utility> <valarray> <list> list list list::list list::~list member functions: list::assign list::back list::begin list::cbegin list::cend list::clear list::crbegin list::crend list::emplace list::emplace_back list::emplace_front list::empty list::end list::erase list::front list::get_allocator list::insert list::max_size list::merge list::operator= list::pop_back list::pop_front list::push_back list::push_front list::rbegin list::remove list::remove_if list::rend list::resize list::reverse list::size list::sort list::splice list::swap list::unique non-member overloads: relational operators (list) swap (list) 			 	Home page | Privacy policy  cplusplus.com, 2000-2017 - All rights reserved - v3.1 Spotted an error? contact us (function(){   // mini cookie-consent code (c) Juan Soulie, 2016   var s ='consent=cookie';   var e = document.createElement('div');   e.innerHTML = 'This website uses cookies. By continuing, you give permission to deploy cookies, as detailed in our privacy policy. ok';   if (document.cookie.indexOf(s)!==-1) return;   var b = document.getElementsByTagName('body')[0];   b.insertBefore(e,b.firstChild);   var x = function() { document.cookie = s+'; path=/'; e.parentNode.removeChild(e); };   e.addEventListener('click',x);   document.addEventListener('scroll',x); })(); 
http://www.cplusplus.com/reference/stack/stack/index.htmlstack stack - C++ Reference   (function() {     var useSSL = 'https:' == document.location.protocol;     var src = (useSSL ? 'https:' : 'http:') +         '//www.googletagservices.com/tag/js/gpt.js';     document.write('');   })(); Search:   Reference <stack> stack class template <stack> std::stack template <class T, class Container = deque<T> > class stack;LIFO stack Stacks are a type of container adaptor, specifically designed to operate in a LIFO context (last-in first-out), where elements are inserted and extracted only from one end of the container.    stacks are implemented as containers adaptors, which are classes that use an encapsulated object of a specific container class as its underlying container, providing a specific set of member functions to access its elements. Elements are pushed/popped from the "back" of the specific container, which is known as the top of the stack.    The underlying container may be any of the standard container class templates or some other specifically designed container class. The container shall support the following operations:  empty size back push_back pop_back   The standard container classes vector, deque and list fulfill these requirements. By default, if no container class is specified for a particular stack class instantiation, the standard container deque is used.    Template parameters T Type of the elements.  Aliased as member type stack::value_type. Container Type of the internal underlying container object where the elements are stored.  Its value_type shall be T.  Aliased as member type stack::container_type.   Member types member typedefinitionnotes value_typeThe first template parameter (T)Type of the elements container_typeThe second template parameter (Container)Type of the underlying container size_typean unsigned integral typeusually the same as size_t member typedefinitionnotes value_typeThe first template parameter (T)Type of the elements container_typeThe second template parameter (Container)Type of the underlying container referencecontainer_type::referenceusually, value_type& const_referencecontainer_type::const_referenceusually, const value_type& size_typean unsigned integral typeusually, the same as size_t   Member functions (constructor)Construct stack (public member function)emptyTest whether container is empty (public member function)sizeReturn size (public member function)topAccess next element (public member function)pushInsert element (public member function)emplace Construct and insert element (public member function)popRemove top element (public member function)swap Swap contents (public member function)   Non-member function overloads relational operatorsRelational operators for stack (function)swap (stack) Exchange contents of stacks (public member function)   Non-member class specializations uses_allocator<stack> Uses allocator for stack (class template) C++ Information Tutorials Reference Articles Forum Reference C library: <cassert> (assert.h) <cctype> (ctype.h) <cerrno> (errno.h) <cfenv> (fenv.h) <cfloat> (float.h) <cinttypes> (inttypes.h) <ciso646> (iso646.h) <climits> (limits.h) <clocale> (locale.h) <cmath> (math.h) <csetjmp> (setjmp.h) <csignal> (signal.h) <cstdarg> (stdarg.h) <cstdbool> (stdbool.h) <cstddef> (stddef.h) <cstdint> (stdint.h) <cstdio> (stdio.h) <cstdlib> (stdlib.h) <cstring> (string.h) <ctgmath> (tgmath.h) <ctime> (time.h) <cuchar> (uchar.h) <cwchar> (wchar.h) <cwctype> (wctype.h) Containers: <array> <deque> <forward_list> <list> <map> <queue> <set> <stack> <unordered_map> <unordered_set> <vector> Input/Output: <fstream> <iomanip> <ios> <iosfwd> <iostream> <istream> <ostream> <sstream> <streambuf> Multi-threading: <atomic> <condition_variable> <future> <mutex> <thread> Other: <algorithm> <bitset> <chrono> <codecvt> <complex> <exception> <functional> <initializer_list> <iterator> <limits> <locale> <memory> <new> <numeric> <random> <ratio> <regex> <stdexcept> <string> <system_error> <tuple> <typeindex> <typeinfo> <type_traits> <utility> <valarray> <stack> stack stack stack::stack member functions: stack::emplace stack::empty stack::pop stack::push stack::size stack::swap stack::top non-member overloads: relational operators (stack) swap (stack) non-member specializations: uses_allocator<stack> 			 	Home page | Privacy policy  cplusplus.com, 2000-2017 - All rights reserved - v3.1 Spotted an error? contact us (function(){   // mini cookie-consent code (c) Juan Soulie, 2016   var s ='consent=cookie';   var e = document.createElement('div');   e.innerHTML = 'This website uses cookies. By continuing, you give permission to deploy cookies, as detailed in our privacy policy. ok';   if (document.cookie.indexOf(s)!==-1) return;   var b = document.getElementsByTagName('body')[0];   b.insertBefore(e,b.firstChild);   var x = function() { document.cookie = s+'; path=/'; e.parentNode.removeChild(e); };   e.addEventListener('click',x);   document.addEventListener('scroll',x); })(); 
http://www.cplusplus.com/reference/queue/queue/index.htmlqueue queue - C++ Reference   (function() {     var useSSL = 'https:' == document.location.protocol;     var src = (useSSL ? 'https:' : 'http:') +         '//www.googletagservices.com/tag/js/gpt.js';     document.write('');   })(); Search:   Reference <queue> queue class template <queue> std::queue template <class T, class Container = deque<T> > class queue;FIFO queue queues are a type of container adaptor, specifically designed to operate in a FIFO context (first-in first-out), where elements are inserted into one end of the container and extracted from the other.    queues are implemented as containers adaptors, which are classes that use an encapsulated object of a specific container class as its underlying container, providing a specific set of member functions to access its elements. Elements are pushed into the "back" of the specific container and popped from its "front".    The underlying container may be one of the standard container class template or some other specifically designed container class. This underlying container shall support at least the following operations:  empty size front back push_back pop_front   The standard container classes deque and list fulfill these requirements. By default, if no container class is specified for a particular queue class instantiation, the standard container deque is used.    Template parameters T Type of the elements.  Aliased as member type queue::value_type. Container Type of the internal underlying container object where the elements are stored.  Its value_type shall be T.  Aliased as member type queue::container_type.   Member types member typedefinitionnotes value_typeThe first template parameter (T)Type of the elements container_typeThe second template parameter (Container)Type of the underlying container size_typean unsigned integral typeusually the same as size_t member typedefinitionnotes value_typeThe first template parameter (T)Type of the elements container_typeThe second template parameter (Container)Type of the underlying container referencecontainer_type::referenceusually, value_type& const_referencecontainer_type::const_referenceusually, const value_type& size_typean unsigned integral typeusually, the same as size_t   Member functions (constructor)Construct queue (public member function)emptyTest whether container is empty (public member function)sizeReturn size (public member function)frontAccess next element (public member function)backAccess last element (public member function)pushInsert element (public member function)emplace Construct and insert element (public member function)popRemove next element (public member function)swap Swap contents (public member function)   Non-member function overloads relational operatorsRelational operators for queue (function)swap (queue) Exchange contents of queues (public member function)   Non-member class specializations uses_allocator<queue> Uses allocator for queue (class template) C++ Information Tutorials Reference Articles Forum Reference C library: <cassert> (assert.h) <cctype> (ctype.h) <cerrno> (errno.h) <cfenv> (fenv.h) <cfloat> (float.h) <cinttypes> (inttypes.h) <ciso646> (iso646.h) <climits> (limits.h) <clocale> (locale.h) <cmath> (math.h) <csetjmp> (setjmp.h) <csignal> (signal.h) <cstdarg> (stdarg.h) <cstdbool> (stdbool.h) <cstddef> (stddef.h) <cstdint> (stdint.h) <cstdio> (stdio.h) <cstdlib> (stdlib.h) <cstring> (string.h) <ctgmath> (tgmath.h) <ctime> (time.h) <cuchar> (uchar.h) <cwchar> (wchar.h) <cwctype> (wctype.h) Containers: <array> <deque> <forward_list> <list> <map> <queue> <set> <stack> <unordered_map> <unordered_set> <vector> Input/Output: <fstream> <iomanip> <ios> <iosfwd> <iostream> <istream> <ostream> <sstream> <streambuf> Multi-threading: <atomic> <condition_variable> <future> <mutex> <thread> Other: <algorithm> <bitset> <chrono> <codecvt> <complex> <exception> <functional> <initializer_list> <iterator> <limits> <locale> <memory> <new> <numeric> <random> <ratio> <regex> <stdexcept> <string> <system_error> <tuple> <typeindex> <typeinfo> <type_traits> <utility> <valarray> <queue> priority_queue queue queue queue::queue member functions: queue::back queue::emplace queue::empty queue::front queue::pop queue::push queue::size queue::swap non-member overloads: relational operators (queue) swap (queue) non-member specializations: uses_allocator<queue> 			 	Home page | Privacy policy  cplusplus.com, 2000-2017 - All rights reserved - v3.1 Spotted an error? contact us (function(){   // mini cookie-consent code (c) Juan Soulie, 2016   var s ='consent=cookie';   var e = document.createElement('div');   e.innerHTML = 'This website uses cookies. By continuing, you give permission to deploy cookies, as detailed in our privacy policy. ok';   if (document.cookie.indexOf(s)!==-1) return;   var b = document.getElementsByTagName('body')[0];   b.insertBefore(e,b.firstChild);   var x = function() { document.cookie = s+'; path=/'; e.parentNode.removeChild(e); };   e.addEventListener('click',x);   document.addEventListener('scroll',x); })(); 
http://www.cplusplus.com/reference/queue/priority_queue/index.htmlpriority_queue priority_queue - C++ Reference   (function() {     var useSSL = 'https:' == document.location.protocol;     var src = (useSSL ? 'https:' : 'http:') +         '//www.googletagservices.com/tag/js/gpt.js';     document.write('');   })(); Search:   Reference <queue> priority_queue class template <queue> std::priority_queue template <class T, class Container = vector<T>,  class Compare = less<typename Container::value_type> > class priority_queue;Priority queue Priority queues are a type of container adaptors, specifically designed such that its first element is always the greatest of the elements it contains, according to some strict weak ordering criterion.    This context is similar to a heap, where elements can be inserted at any moment, and only the max heap element can be retrieved (the one at the top in the priority queue).    Priority queues are implemented as container adaptors, which are classes that use an encapsulated object of a specific container class as its underlying container, providing a specific set of member functions to access its elements. Elements are popped from the "back" of the specific container, which is known as the top of the priority queue.    The underlying container may be any of the standard container class templates or some other specifically designed container class. The container shall be accessible through random access iterators and support the following operations:  empty() size() front() push_back() pop_back()   The standard container classes vector and deque fulfill these requirements. By default, if no container class is specified for a particular priority_queue class instantiation, the standard container vector is used.    Support of random access iterators is required to keep a heap structure internally at all times. This is done automatically by the container adaptor by automatically calling the algorithm functions make_heap, push_heap and pop_heap when needed.    Template parameters T Type of the elements.  Aliased as member type priority_queue::value_type. Container Type of the internal underlying container object where the elements are stored.  Its value_type shall be T.  Aliased as member type priority_queue::container_type. Compare A binary predicate that takes two elements (of type T) as arguments and returns a bool.  The expression comp(a,b), where comp is an object of this type and a and b are elements in the container, shall return true if a is considered to go before b in the strict weak ordering the function defines.  The priority_queue uses this function to maintain the elements sorted in a way that preserves heap properties (i.e., that the element popped is the last according to this strict weak ordering).  This can be a function pointer or a function object, and defaults to less<T>, which returns the same as applying the less-than operator (a<b).   Member types member typedefinitionnotes value_typeThe first template parameter (T)Type of the elements container_typeThe second template parameter (Container)Type of the underlying container size_typean unsigned integral typeusually the same as size_t member typedefinitionnotes value_typeThe first template parameter (T)Type of the elements container_typeThe second template parameter (Container)Type of the underlying container referencecontainer_type::referenceusually, value_type& const_referencecontainer_type::const_referenceusually, const value_type& size_typean unsigned integral typeusually, the same as size_t   Member functions (constructor)Construct priority queue (public member function)emptyTest whether container is empty (public member function)sizeReturn size (public member function)topAccess top element (public member function)pushInsert element (public member function)emplace Construct and insert element (public member function)popRemove top element (public member function)swap Swap contents (public member function)   Non-member function overloads swap (queue) Exchange contents of priority queues (public member function)   Non-member class specializations uses_allocator<queue> Uses allocator for priority queue (class template) C++ Information Tutorials Reference Articles Forum Reference C library: <cassert> (assert.h) <cctype> (ctype.h) <cerrno> (errno.h) <cfenv> (fenv.h) <cfloat> (float.h) <cinttypes> (inttypes.h) <ciso646> (iso646.h) <climits> (limits.h) <clocale> (locale.h) <cmath> (math.h) <csetjmp> (setjmp.h) <csignal> (signal.h) <cstdarg> (stdarg.h) <cstdbool> (stdbool.h) <cstddef> (stddef.h) <cstdint> (stdint.h) <cstdio> (stdio.h) <cstdlib> (stdlib.h) <cstring> (string.h) <ctgmath> (tgmath.h) <ctime> (time.h) <cuchar> (uchar.h) <cwchar> (wchar.h) <cwctype> (wctype.h) Containers: <array> <deque> <forward_list> <list> <map> <queue> <set> <stack> <unordered_map> <unordered_set> <vector> Input/Output: <fstream> <iomanip> <ios> <iosfwd> <iostream> <istream> <ostream> <sstream> <streambuf> Multi-threading: <atomic> <condition_variable> <future> <mutex> <thread> Other: <algorithm> <bitset> <chrono> <codecvt> <complex> <exception> <functional> <initializer_list> <iterator> <limits> <locale> <memory> <new> <numeric> <random> <ratio> <regex> <stdexcept> <string> <system_error> <tuple> <typeindex> <typeinfo> <type_traits> <utility> <valarray> <queue> priority_queue queue priority_queue priority_queue::priority_queue member functions: priority_queue::emplace priority_queue::empty priority_queue::pop priority_queue::push priority_queue::size priority_queue::swap priority_queue::top non-member overloads: swap (priority_queue) non-member specializations: uses_allocator<priority_queue> 			 	Home page | Privacy policy  cplusplus.com, 2000-2017 - All rights reserved - v3.1 Spotted an error? contact us (function(){   // mini cookie-consent code (c) Juan Soulie, 2016   var s ='consent=cookie';   var e = document.createElement('div');   e.innerHTML = 'This website uses cookies. By continuing, you give permission to deploy cookies, as detailed in our privacy policy. ok';   if (document.cookie.indexOf(s)!==-1) return;   var b = document.getElementsByTagName('body')[0];   b.insertBefore(e,b.firstChild);   var x = function() { document.cookie = s+'; path=/'; e.parentNode.removeChild(e); };   e.addEventListener('click',x);   document.addEventListener('scroll',x); })(); 
http://www.cplusplus.com/reference/set/set/index.htmlset set - C++ Reference   (function() {     var useSSL = 'https:' == document.location.protocol;     var src = (useSSL ? 'https:' : 'http:') +         '//www.googletagservices.com/tag/js/gpt.js';     document.write('');   })(); Search:   Reference <set> set class template <set> std::set template < class T,                        // set::key_type/value_type           class Compare = less<T>,        // set::key_compare/value_compare           class Alloc = allocator<T>      // set::allocator_type           > class set;Set Sets are containers that store unique elements following a specific order.    In a set, the value of an element also identifies it (the value is itself the key, of type T), and each value must be unique. The value of the elements in a set cannot be modified once in the container (the elements are always const), but they can be inserted or removed from the container.    Internally, the elements in a set are always sorted following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare).    set containers are generally slower than unordered_set containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order.    Sets are typically implemented as binary search trees.    Container properties Associative Elements in associative containers are referenced by their key and not by their absolute position in the container. Ordered The elements in the container follow a strict order at all times. All inserted elements are given a position in this order. Set The value of an element is also the key used to identify it. Unique keys No two elements in the container can have equivalent keys. Allocator-aware The container uses an allocator object to dynamically handle its storage needs.   Template parameters T Type of the elements. Each element in a set container is also uniquely identified by this value (each value is itself also the element's key).  Aliased as member types set::key_type and set::value_type. Compare A binary predicate that takes two arguments of the same type as the elements and returns a bool. The expression comp(a,b), where comp is an object of this type and a and b are key values, shall return true if a is considered to go before b in the strict weak ordering the function defines.  The set object uses this expression to determine both the order the elements follow in the container and whether two element keys are equivalent (by comparing them reflexively: they are equivalent if !comp(a,b) && !comp(b,a)). No two elements in a set container can be equivalent.  This can be a function pointer or a function object (see constructor for an example). This defaults to less<T>, which returns the same as applying the less-than operator (a<b).  Aliased as member types set::key_compare and set::value_compare. Alloc Type of the allocator object used to define the storage allocation model. By default, the allocator class template is used, which defines the simplest memory allocation model and is value-independent.  Aliased as member type set::allocator_type.   Member types member typedefinitionnotes key_typeThe first template parameter (T) value_typeThe first template parameter (T) key_compareThe second template parameter (Compare)defaults to: less<key_type> value_compareThe second template parameter (Compare)defaults to: less<value_type> allocator_typeThe third template parameter (Alloc)defaults to: allocator<value_type> referenceallocator_type::referencefor the default allocator: value_type& const_referenceallocator_type::const_referencefor the default allocator: const value_type& pointerallocator_type::pointerfor the default allocator: value_type* const_pointerallocator_type::const_pointerfor the default allocator: const value_type* iteratora bidirectional iterator to value_typeconvertible to const_iterator const_iteratora bidirectional iterator to const value_type reverse_iteratorreverse_iterator<iterator> const_reverse_iteratorreverse_iterator<const_iterator> difference_typea signed integral type, identical to: iterator_traits<iterator>::difference_typeusually the same as ptrdiff_t size_typean unsigned integral type that can represent any non-negative value of difference_typeusually the same as size_t member typedefinitionnotes key_typeThe first template parameter (T) value_typeThe first template parameter (T) key_compareThe second template parameter (Compare)defaults to: less<key_type> value_compareThe second template parameter (Compare)defaults to: less<value_type> allocator_typeThe third template parameter (Alloc)defaults to: allocator<value_type> referencevalue_type& const_referenceconst value_type& pointerallocator_traits<allocator_type>::pointerfor the default allocator: value_type* const_pointerallocator_traits<allocator_type>::const_pointerfor the default allocator: const value_type* iteratora bidirectional iterator to const value_type* convertible to const_iterator const_iteratora bidirectional iterator to const value_type* reverse_iteratorreverse_iterator<iterator>* const_reverse_iteratorreverse_iterator<const_iterator>* difference_typea signed integral type, identical to:  iterator_traits<iterator>::difference_typeusually the same as ptrdiff_t size_typean unsigned integral type that can represent any non-negative value of difference_typeusually the same as size_t *Note: All iterators in a set point to const elements. Whether the const_ member type is the same type as its non-const_ counterpart depends on the particular library implementation, but programs should not rely on them being different to overload functions: const_iterator is more generic, since iterator is always convertible to it.    Member functions (constructor)Construct set (public member function)(destructor)Set destructor (public member function)operator=Copy container content (public member function)   Iterators:  beginReturn iterator to beginning (public member function)endReturn iterator to end (public member function)rbeginReturn reverse iterator to reverse beginning (public member function)rendReturn reverse iterator to reverse end (public member function)cbegin Return const_iterator to beginning (public member function)cend Return const_iterator to end (public member function)crbegin Return const_reverse_iterator to reverse beginning (public member function)crend Return const_reverse_iterator to reverse end (public member function)   Capacity:  emptyTest whether container is empty (public member function)sizeReturn container size (public member function)max_sizeReturn maximum size (public member function)   Modifiers:  insertInsert element (public member function)eraseErase elements (public member function)swapSwap content (public member function)clearClear content (public member function)emplace Construct and insert element (public member function)emplace_hint Construct and insert element with hint (public member function)   Observers:  key_compReturn comparison object (public member function)value_compReturn comparison object (public member function)   Operations:  findGet iterator to element (public member function)countCount elements with a specific value (public member function)lower_boundReturn iterator to lower bound (public member function)upper_boundReturn iterator to upper bound (public member function)equal_rangeGet range of equal elements (public member function)   Allocator:  get_allocatorGet allocator (public member function) C++ Information Tutorials Reference Articles Forum Reference C library: <cassert> (assert.h) <cctype> (ctype.h) <cerrno> (errno.h) <cfenv> (fenv.h) <cfloat> (float.h) <cinttypes> (inttypes.h) <ciso646> (iso646.h) <climits> (limits.h) <clocale> (locale.h) <cmath> (math.h) <csetjmp> (setjmp.h) <csignal> (signal.h) <cstdarg> (stdarg.h) <cstdbool> (stdbool.h) <cstddef> (stddef.h) <cstdint> (stdint.h) <cstdio> (stdio.h) <cstdlib> (stdlib.h) <cstring> (string.h) <ctgmath> (tgmath.h) <ctime> (time.h) <cuchar> (uchar.h) <cwchar> (wchar.h) <cwctype> (wctype.h) Containers: <array> <deque> <forward_list> <list> <map> <queue> <set> <stack> <unordered_map> <unordered_set> <vector> Input/Output: <fstream> <iomanip> <ios> <iosfwd> <iostream> <istream> <ostream> <sstream> <streambuf> Multi-threading: <atomic> <condition_variable> <future> <mutex> <thread> Other: <algorithm> <bitset> <chrono> <codecvt> <complex> <exception> <functional> <initializer_list> <iterator> <limits> <locale> <memory> <new> <numeric> <random> <ratio> <regex> <stdexcept> <string> <system_error> <tuple> <typeindex> <typeinfo> <type_traits> <utility> <valarray> <set> multiset set set set::set set::~set member functions: set::begin set::cbegin set::cend set::clear set::count set::crbegin set::crend set::emplace set::emplace_hint set::empty set::end set::equal_range set::erase set::find set::get_allocator set::insert set::key_comp set::lower_bound set::max_size set::operator= set::rbegin set::rend set::size set::swap set::upper_bound set::value_comp non-member overloads: relational operators (set) swap (set) 			 	Home page | Privacy policy  cplusplus.com, 2000-2017 - All rights reserved - v3.1 Spotted an error? contact us (function(){   // mini cookie-consent code (c) Juan Soulie, 2016   var s ='consent=cookie';   var e = document.createElement('div');   e.innerHTML = 'This website uses cookies. By continuing, you give permission to deploy cookies, as detailed in our privacy policy. ok';   if (document.cookie.indexOf(s)!==-1) return;   var b = document.getElementsByTagName('body')[0];   b.insertBefore(e,b.firstChild);   var x = function() { document.cookie = s+'; path=/'; e.parentNode.removeChild(e); };   e.addEventListener('click',x);   document.addEventListener('scroll',x); })(); 
http://www.cplusplus.com/reference/set/multiset/index.htmlmultiset multiset - C++ Reference   (function() {     var useSSL = 'https:' == document.location.protocol;     var src = (useSSL ? 'https:' : 'http:') +         '//www.googletagservices.com/tag/js/gpt.js';     document.write('');   })(); Search:   Reference <set> multiset class template <set> std::multiset template < class T,                        // multiset::key_type/value_type           class Compare = less<T>,        // multiset::key_compare/value_compare           class Alloc = allocator<T> >    // multiset::allocator_type           > class multiset;Multiple-key set Multisets are containers that store elements following a specific order, and where multiple elements can have equivalent values.    In a multiset, the value of an element also identifies it (the value is itself the key, of type T). The value of the elements in a multiset cannot be modified once in the container (the elements are always const), but they can be inserted or removed from the container.    Internally, the elements in a multiset are always sorted following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare).    multiset containers are generally slower than unordered_multiset containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order.    Multisets are typically implemented as binary search trees.    Container properties Associative Elements in associative containers are referenced by their key and not by their absolute position in the container. Ordered The elements in the container follow a strict order at all times. All inserted elements are given a position in this order. Set The value of an element is also the key used to identify it. Multiple equivalent keys Multiple elements in the container can have equivalent keys. Allocator-aware The container uses an allocator object to dynamically handle its storage needs.   Template parameters T Type of the elements. Each element in a multiset container is also identified by this value (each value is itself also the element's key).  Aliased as member types multiset::key_type and multiset::value_type. Compare A binary predicate that takes two arguments of the same type as the elements and returns a bool. The expression comp(a,b), where comp is an object of this type and a and b are key values, shall return true if a is considered to go before b in the strict weak ordering the function defines.  The multiset object uses this expression to determine both the order the elements follow in the container and whether two element keys are equivalent (by comparing them reflexively: they are equivalent if !comp(a,b) && !comp(b,a)).  This can be a function pointer or a function object (see constructor for an example). This defaults to less<T>, which returns the same as applying the less-than operator (a<b).  Aliased as member types multiset::key_compare and multiset::value_compare. Alloc Type of the allocator object used to define the storage allocation model. By default, the allocator class template is used, which defines the simplest memory allocation model and is value-independent.  Aliased as member type multiset::allocator_type.   Member types member typedefinitionnotes key_typeThe first template parameter (T) value_typeThe first template parameter (T) key_compareThe second template parameter (Compare)defaults to: less<key_type> value_compareThe second template parameter (Compare)defaults to: less<value_type> allocator_typeThe third template parameter (Alloc)defaults to: allocator<value_type> referenceallocator_type::referencefor the default allocator: value_type& const_referenceallocator_type::const_referencefor the default allocator: const value_type& pointerallocator_type::pointerfor the default allocator: value_type* const_pointerallocator_type::const_pointerfor the default allocator: const value_type* iteratora bidirectional iterator to value_typeconvertible to const_iterator const_iteratora bidirectional iterator to const value_type reverse_iteratorreverse_iterator<iterator> const_reverse_iteratorreverse_iterator<const_iterator> difference_typea signed integral type, identical to: iterator_traits<iterator>::difference_typeusually the same as ptrdiff_t size_typean unsigned integral type that can represent any non-negative value of difference_typeusually the same as size_t member typedefinitionnotes key_typeThe first template parameter (T) value_typeThe first template parameter (T) key_compareThe second template parameter (Compare)defaults to: less<key_type> value_compareThe second template parameter (Compare)defaults to: less<value_type> allocator_typeThe third template parameter (Alloc)defaults to: allocator<value_type> referencevalue_type& const_referenceconst value_type& pointerallocator_traits<allocator_type>::pointerfor the default allocator: value_type* const_pointerallocator_traits<allocator_type>::const_pointerfor the default allocator: const value_type* iteratora bidirectional iterator to const value_type* convertible to const_iterator const_iteratora bidirectional iterator to const value_type*  reverse_iteratorreverse_iterator<iterator>* const_reverse_iteratorreverse_iterator<const_iterator>* difference_typea signed integral type, identical to:  iterator_traits<iterator>::difference_typeusually the same as ptrdiff_t size_typean unsigned integral type that can represent any non-negative value of difference_typeusually the same as size_t *Note: All iterators in a multiset point to const elements. Whether the const_ member type is the same type as its non-const_ counterpart depends on the particular library implementation, but programs should not rely on them being different to overload functions: const_iterator is more generic, since iterator is always convertible to it.    Member functions (constructor)Construct multiset (public member function)(destructor)Multiset destructor (public member function)operator=Copy container content (public member function)   Iterators:  beginReturn iterator to beginning (public member function)endReturn iterator to end (public member function)rbeginReturn reverse iterator to reverse beginning (public member function)rendReturn reverse iterator to reverse end (public member function)cbegin Return const_iterator to beginning (public member function)cend Return const_iterator to end (public member function)crbegin Return const_reverse_iterator to reverse beginning (public member function)crend Return const_reverse_iterator to reverse end (public member function)   Capacity:  emptyTest whether container is empty (public member function)sizeReturn container size (public member function)max_sizeReturn maximum size (public member function)   Modifiers:  insertInsert element (public member function)eraseErase elements (public member function)swapSwap content (public member function)clearClear content (public member function)emplace Construct and insert element (public member function)emplace_hint Construct and insert element with hint (public member function)   Observers:  key_compReturn comparison object (public member function)value_compReturn comparison object (public member function)   Operations:  findGet iterator to element (public member function)countCount elements with a specific key (public member function)lower_boundReturn iterator to lower bound (public member function)upper_boundReturn iterator to upper bound (public member function)equal_rangeGet range of equal elements (public member function)   Allocator:  get_allocatorGet allocator (public member function) C++ Information Tutorials Reference Articles Forum Reference C library: <cassert> (assert.h) <cctype> (ctype.h) <cerrno> (errno.h) <cfenv> (fenv.h) <cfloat> (float.h) <cinttypes> (inttypes.h) <ciso646> (iso646.h) <climits> (limits.h) <clocale> (locale.h) <cmath> (math.h) <csetjmp> (setjmp.h) <csignal> (signal.h) <cstdarg> (stdarg.h) <cstdbool> (stdbool.h) <cstddef> (stddef.h) <cstdint> (stdint.h) <cstdio> (stdio.h) <cstdlib> (stdlib.h) <cstring> (string.h) <ctgmath> (tgmath.h) <ctime> (time.h) <cuchar> (uchar.h) <cwchar> (wchar.h) <cwctype> (wctype.h) Containers: <array> <deque> <forward_list> <list> <map> <queue> <set> <stack> <unordered_map> <unordered_set> <vector> Input/Output: <fstream> <iomanip> <ios> <iosfwd> <iostream> <istream> <ostream> <sstream> <streambuf> Multi-threading: <atomic> <condition_variable> <future> <mutex> <thread> Other: <algorithm> <bitset> <chrono> <codecvt> <complex> <exception> <functional> <initializer_list> <iterator> <limits> <locale> <memory> <new> <numeric> <random> <ratio> <regex> <stdexcept> <string> <system_error> <tuple> <typeindex> <typeinfo> <type_traits> <utility> <valarray> <set> multiset set multiset multiset::multiset multiset::~multiset member functions: multiset::begin multiset::cbegin multiset::cend multiset::clear multiset::count multiset::crbegin multiset::crend multiset::emplace multiset::emplace_hint multiset::empty multiset::end multiset::equal_range multiset::erase multiset::find multiset::get_allocator multiset::insert multiset::key_comp multiset::lower_bound multiset::max_size multiset::operator= multiset::rbegin multiset::rend multiset::size multiset::swap multiset::upper_bound multiset::value_comp non-member overloads: relational operators (multiset) swap (multiset) 			 	Home page | Privacy policy  cplusplus.com, 2000-2017 - All rights reserved - v3.1 Spotted an error? contact us (function(){   // mini cookie-consent code (c) Juan Soulie, 2016   var s ='consent=cookie';   var e = document.createElement('div');   e.innerHTML = 'This website uses cookies. By continuing, you give permission to deploy cookies, as detailed in our privacy policy. ok';   if (document.cookie.indexOf(s)!==-1) return;   var b = document.getElementsByTagName('body')[0];   b.insertBefore(e,b.firstChild);   var x = function() { document.cookie = s+'; path=/'; e.parentNode.removeChild(e); };   e.addEventListener('click',x);   document.addEventListener('scroll',x); })(); 
http://www.cplusplus.com/reference/map/map/index.htmlmap map - C++ Reference   (function() {     var useSSL = 'https:' == document.location.protocol;     var src = (useSSL ? 'https:' : 'http:') +         '//www.googletagservices.com/tag/js/gpt.js';     document.write('');   })(); Search:   Reference <map> map class template <map> std::map template < class Key,                                     // map::key_type           class T,                                       // map::mapped_type           class Compare = less<Key>,                     // map::key_compare           class Alloc = allocator<pair<const Key,T> >    // map::allocator_type           > class map;Map Maps are associative containers that store elements formed by a combination of a key value and a mapped value, following a specific order.    In a map, the key values are generally used to sort and uniquely identify the elements, while the mapped values store the content associated to this key. The types of key and mapped value may differ, and are grouped together in member type value_type, which is a pair type combining both:      typedef pair<const Key, T> value_type;     Internally, the elements in a map are always sorted by its key following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare).    map containers are generally slower than unordered_map containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order.    The mapped values in a map can be accessed directly by their corresponding key using the bracket operator ((operator[]).    Maps are typically implemented as binary search trees.    Container properties Associative Elements in associative containers are referenced by their key and not by their absolute position in the container. Ordered The elements in the container follow a strict order at all times. All inserted elements are given a position in this order. Map Each element associates a key to a mapped value: Keys are meant to identify the elements whose main content is the mapped value. Unique keys No two elements in the container can have equivalent keys. Allocator-aware The container uses an allocator object to dynamically handle its storage needs.   Template parameters Key Type of the keys. Each element in a map is uniquely identified by its key value.  Aliased as member type map::key_type. T Type of the mapped value. Each element in a map stores some data as its mapped value.  Aliased as member type map::mapped_type. Compare A binary predicate that takes two element keys as arguments and returns a bool. The expression comp(a,b), where comp is an object of this type and a and b are key values, shall return true if a is considered to go before b in the strict weak ordering the function defines.  The map object uses this expression to determine both the order the elements follow in the container and whether two element keys are equivalent (by comparing them reflexively: they are equivalent if !comp(a,b) && !comp(b,a)). No two elements in a map container can have equivalent keys.  This can be a function pointer or a function object (see constructor for an example). This defaults to less<T>, which returns the same as applying the less-than operator (a<b).  Aliased as member type map::key_compare. Alloc Type of the allocator object used to define the storage allocation model. By default, the allocator class template is used, which defines the simplest memory allocation model and is value-independent.  Aliased as member type map::allocator_type.   Member types member typedefinitionnotes key_typeThe first template parameter (Key) mapped_typeThe second template parameter (T) value_typepair<const key_type,mapped_type> key_compareThe third template parameter (Compare)defaults to: less<key_type> value_compareNested function class to compare elementssee value_comp allocator_typeThe fourth template parameter (Alloc)defaults to: allocator<value_type> referenceallocator_type::referencefor the default allocator: value_type& const_referenceallocator_type::const_referencefor the default allocator: const value_type& pointerallocator_type::pointerfor the default allocator: value_type* const_pointerallocator_type::const_pointerfor the default allocator: const value_type* iteratora bidirectional iterator to value_typeconvertible to const_iterator const_iteratora bidirectional iterator to const value_type reverse_iteratorreverse_iterator<iterator> const_reverse_iteratorreverse_iterator<const_iterator> difference_typea signed integral type, identical to: iterator_traits<iterator>::difference_typeusually the same as ptrdiff_t size_typean unsigned integral type that can represent any non-negative value of difference_typeusually the same as size_t member typedefinitionnotes key_typeThe first template parameter (Key) mapped_typeThe second template parameter (T) value_typepair<const key_type,mapped_type> key_compareThe third template parameter (Compare)defaults to: less<key_type> value_compareNested function class to compare elementssee value_comp allocator_typeThe fourth template parameter (Alloc)defaults to: allocator<value_type> referencevalue_type& const_referenceconst value_type& pointerallocator_traits<allocator_type>::pointerfor the default allocator: value_type* const_pointerallocator_traits<allocator_type>::const_pointerfor the default allocator: const value_type* iteratora bidirectional iterator to value_typeconvertible to const_iterator const_iteratora bidirectional iterator to const value_type reverse_iteratorreverse_iterator<iterator> const_reverse_iteratorreverse_iterator<const_iterator> difference_typea signed integral type, identical to:  iterator_traits<iterator>::difference_typeusually the same as ptrdiff_t size_typean unsigned integral type that can represent any non-negative value of difference_typeusually the same as size_t   Member functions (constructor)Construct map (public member function)(destructor)Map destructor (public member function)operator=Copy container content (public member function)   Iterators:  beginReturn iterator to beginning (public member function)endReturn iterator to end (public member function)rbeginReturn reverse iterator to reverse beginning (public member function)rendReturn reverse iterator to reverse end (public member function)cbegin Return const_iterator to beginning (public member function)cend Return const_iterator to end (public member function)crbegin Return const_reverse_iterator to reverse beginning (public member function)crend Return const_reverse_iterator to reverse end (public member function)   Capacity:  emptyTest whether container is empty (public member function)sizeReturn container size (public member function)max_sizeReturn maximum size (public member function)   Element access:  operator[]Access element (public member function)at Access element (public member function)   Modifiers:  insertInsert elements (public member function)eraseErase elements (public member function)swapSwap content (public member function)clearClear content (public member function)emplace Construct and insert element (public member function)emplace_hint Construct and insert element with hint (public member function)   Observers:  key_compReturn key comparison object (public member function)value_compReturn value comparison object (public member function)   Operations:  findGet iterator to element (public member function)countCount elements with a specific key (public member function)lower_boundReturn iterator to lower bound (public member function)upper_boundReturn iterator to upper bound (public member function)equal_rangeGet range of equal elements (public member function)   Allocator:  get_allocatorGet allocator (public member function) C++ Information Tutorials Reference Articles Forum Reference C library: <cassert> (assert.h) <cctype> (ctype.h) <cerrno> (errno.h) <cfenv> (fenv.h) <cfloat> (float.h) <cinttypes> (inttypes.h) <ciso646> (iso646.h) <climits> (limits.h) <clocale> (locale.h) <cmath> (math.h) <csetjmp> (setjmp.h) <csignal> (signal.h) <cstdarg> (stdarg.h) <cstdbool> (stdbool.h) <cstddef> (stddef.h) <cstdint> (stdint.h) <cstdio> (stdio.h) <cstdlib> (stdlib.h) <cstring> (string.h) <ctgmath> (tgmath.h) <ctime> (time.h) <cuchar> (uchar.h) <cwchar> (wchar.h) <cwctype> (wctype.h) Containers: <array> <deque> <forward_list> <list> <map> <queue> <set> <stack> <unordered_map> <unordered_set> <vector> Input/Output: <fstream> <iomanip> <ios> <iosfwd> <iostream> <istream> <ostream> <sstream> <streambuf> Multi-threading: <atomic> <condition_variable> <future> <mutex> <thread> Other: <algorithm> <bitset> <chrono> <codecvt> <complex> <exception> <functional> <initializer_list> <iterator> <limits> <locale> <memory> <new> <numeric> <random> <ratio> <regex> <stdexcept> <string> <system_error> <tuple> <typeindex> <typeinfo> <type_traits> <utility> <valarray> <map> map multimap map map::map map::~map member functions: map::at map::begin map::cbegin map::cend map::clear map::count map::crbegin map::crend map::emplace map::emplace_hint map::empty map::end map::equal_range map::erase map::find map::get_allocator map::insert map::key_comp map::lower_bound map::max_size map::operator= map::operator[] map::rbegin map::rend map::size map::swap map::upper_bound map::value_comp non-member overloads: relational operators (map) swap (map) 			 	Home page | Privacy policy  cplusplus.com, 2000-2017 - All rights reserved - v3.1 Spotted an error? contact us (function(){   // mini cookie-consent code (c) Juan Soulie, 2016   var s ='consent=cookie';   var e = document.createElement('div');   e.innerHTML = 'This website uses cookies. By continuing, you give permission to deploy cookies, as detailed in our privacy policy. ok';   if (document.cookie.indexOf(s)!==-1) return;   var b = document.getElementsByTagName('body')[0];   b.insertBefore(e,b.firstChild);   var x = function() { document.cookie = s+'; path=/'; e.parentNode.removeChild(e); };   e.addEventListener('click',x);   document.addEventListener('scroll',x); })(); 
http://www.cplusplus.com/reference/map/multimap/index.htmlmultimap multimap - C++ Reference   (function() {     var useSSL = 'https:' == document.location.protocol;     var src = (useSSL ? 'https:' : 'http:') +         '//www.googletagservices.com/tag/js/gpt.js';     document.write('');   })(); Search:   Reference <map> multimap class template <map> std::multimap template < class Key,                                     // multimap::key_type           class T,                                       // multimap::mapped_type           class Compare = less<Key>,                     // multimap::key_compare           class Alloc = allocator<pair<const Key,T> >    // multimap::allocator_type           > class multimap;Multiple-key map Multimaps are associative containers that store elements formed by a combination of a key value and a mapped value, following a specific order, and where multiple elements can have equivalent keys.    In a multimap, the key values are generally used to sort and uniquely identify the elements, while the mapped values store the content associated to this key. The types of key and mapped value may differ, and are grouped together in member type value_type, which is a pair type combining both:      typedef pair<const Key, T> value_type;     Internally, the elements in a multimap are always sorted by its key following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare).    multimap containers are generally slower than unordered_multimap containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order.    Multimaps are typically implemented as binary search trees.    Container properties Associative Elements in associative containers are referenced by their key and not by their absolute position in the container. Ordered The elements in the container follow a strict order at all times. All inserted elements are given a position in this order. Map Each element associates a key to a mapped value: Keys are meant to identify the elements whose main content is the mapped value. Multiple equivalent keys Multiple elements in the container can have equivalent keys. Allocator-aware The container uses an allocator object to dynamically handle its storage needs.   Template parameters Key Type of the keys. Each element in a map is identified by its key value.  Aliased as member type multimap::key_type. T Type of the mapped value. Each element in a multimap stores some data as its mapped value.  Aliased as member type multimap::mapped_type. Compare A binary predicate that takes two element keys as arguments and returns a bool. The expression comp(a,b), where comp is an object of this type and a and b are element keys, shall return true if a is considered to go before b in the strict weak ordering the function defines.  The multimap object uses this expression to determine both the order the elements follow in the container and whether two element keys are equivalent (by comparing them reflexively: they are equivalent if !comp(a,b) && !comp(b,a)).  This can be a function pointer or a function object (see constructor for an example). This defaults to less<T>, which returns the same as applying the less-than operator (a<b).  Aliased as member type multimap::key_compare. Alloc Type of the allocator object used to define the storage allocation model. By default, the allocator class template is used, which defines the simplest memory allocation model and is value-independent.  Aliased as member type multimap::allocator_type.   Member types member typedefinitionnotes key_typeThe first template parameter (Key) mapped_typeThe second template parameter (T) value_typepair<const key_type,mapped_type> key_compareThe third template parameter (Compare)defaults to: less<key_type> value_compareNested function class to compare elementssee value_comp allocator_typeThe fourth template parameter (Alloc)defaults to: allocator<value_type> referenceallocator_type::referencefor the default allocator: value_type& const_referenceallocator_type::const_referencefor the default allocator: const value_type& pointerallocator_type::pointerfor the default allocator: value_type* const_pointerallocator_type::const_pointerfor the default allocator: const value_type* iteratora bidirectional iterator to value_typeconvertible to const_iterator const_iteratora bidirectional iterator to const value_type reverse_iteratorreverse_iterator<iterator> const_reverse_iteratorreverse_iterator<const_iterator> difference_typea signed integral type, identical to: iterator_traits<iterator>::difference_typeusually the same as ptrdiff_t size_typean unsigned integral type that can represent any non-negative value of difference_typeusually the same as size_t member typedefinitionnotes key_typeThe first template parameter (Key) mapped_typeThe second template parameter (T) value_typepair<const key_type,mapped_type> key_compareThe third template parameter (Compare)defaults to: less<key_type> value_compareNested function class to compare elementssee value_comp allocator_typeThe fourth template parameter (Alloc)defaults to: allocator<value_type> referencevalue_type& const_referenceconst value_type& pointerallocator_traits<allocator_type>::pointerfor the default allocator: value_type* const_pointerallocator_traits<allocator_type>::const_pointerfor the default allocator: const value_type* iteratora bidirectional iterator to value_typeconvertible to const_iterator const_iteratora bidirectional iterator to const value_type reverse_iteratorreverse_iterator<iterator> const_reverse_iteratorreverse_iterator<const_iterator> difference_typea signed integral type, identical to:  iterator_traits<iterator>::difference_typeusually the same as ptrdiff_t size_typean unsigned integral type that can represent any non-negative value of difference_typeusually the same as size_t   Member functions (constructor)Construct multimap (public member function)(destructor)Multimap destructor (public member function)operator=Copy container content (public member function)   Iterators:  beginReturn iterator to beginning (public member function)endReturn iterator to end (public member function)rbeginReturn reverse iterator to reverse beginning (public member function)rendReturn reverse iterator to reverse end (public member function)cbegin Return const_iterator to beginning (public member function)cend Return const_iterator to end (public member function)crbegin Return const_reverse_iterator to reverse beginning (public member function)crend Return const_reverse_iterator to reverse end (public member function)   Capacity:  emptyTest whether container is empty (public member function)sizeReturn container size (public member function)max_sizeReturn maximum size (public member function)   Modifiers:  insertInsert element (public member function)eraseErase elements (public member function)swapSwap content (public member function)clearClear content (public member function)emplace Construct and insert element (public member function)emplace_hint Construct and insert element with hint (public member function)   Observers:  key_compReturn key comparison object (public member function)value_compReturn value comparison object (public member function)   Operations:  findGet iterator to element (public member function)countCount elements with a specific key (public member function)lower_boundReturn iterator to lower bound (public member function)upper_boundReturn iterator to upper bound (public member function)equal_rangeGet range of equal elements (public member function)   Allocator:  get_allocatorGet allocator (public member function) C++ Information Tutorials Reference Articles Forum Reference C library: <cassert> (assert.h) <cctype> (ctype.h) <cerrno> (errno.h) <cfenv> (fenv.h) <cfloat> (float.h) <cinttypes> (inttypes.h) <ciso646> (iso646.h) <climits> (limits.h) <clocale> (locale.h) <cmath> (math.h) <csetjmp> (setjmp.h) <csignal> (signal.h) <cstdarg> (stdarg.h) <cstdbool> (stdbool.h) <cstddef> (stddef.h) <cstdint> (stdint.h) <cstdio> (stdio.h) <cstdlib> (stdlib.h) <cstring> (string.h) <ctgmath> (tgmath.h) <ctime> (time.h) <cuchar> (uchar.h) <cwchar> (wchar.h) <cwctype> (wctype.h) Containers: <array> <deque> <forward_list> <list> <map> <queue> <set> <stack> <unordered_map> <unordered_set> <vector> Input/Output: <fstream> <iomanip> <ios> <iosfwd> <iostream> <istream> <ostream> <sstream> <streambuf> Multi-threading: <atomic> <condition_variable> <future> <mutex> <thread> Other: <algorithm> <bitset> <chrono> <codecvt> <complex> <exception> <functional> <initializer_list> <iterator> <limits> <locale> <memory> <new> <numeric> <random> <ratio> <regex> <stdexcept> <string> <system_error> <tuple> <typeindex> <typeinfo> <type_traits> <utility> <valarray> <map> map multimap multimap multimap::multimap multimap::~multimap member functions: multimap::begin multimap::cbegin multimap::cend multimap::clear multimap::count multimap::crbegin multimap::crend multimap::emplace multimap::emplace_hint multimap::empty multimap::end multimap::equal_range multimap::erase multimap::find multimap::get_allocator multimap::insert multimap::key_comp multimap::lower_bound multimap::max_size multimap::operator= multimap::rbegin multimap::rend multimap::size multimap::swap multimap::upper_bound multimap::value_comp non-member overloads: relational operators (multimap) swap (multimap) 			 	Home page | Privacy policy  cplusplus.com, 2000-2017 - All rights reserved - v3.1 Spotted an error? contact us (function(){   // mini cookie-consent code (c) Juan Soulie, 2016   var s ='consent=cookie';   var e = document.createElement('div');   e.innerHTML = 'This website uses cookies. By continuing, you give permission to deploy cookies, as detailed in our privacy policy. ok';   if (document.cookie.indexOf(s)!==-1) return;   var b = document.getElementsByTagName('body')[0];   b.insertBefore(e,b.firstChild);   var x = function() { document.cookie = s+'; path=/'; e.parentNode.removeChild(e); };   e.addEventListener('click',x);   document.addEventListener('scroll',x); })(); 
http://www.cplusplus.com/reference/unordered_set/unordered_set/index.htmlunordered_set unordered_set - C++ Reference   (function() {     var useSSL = 'https:' == document.location.protocol;     var src = (useSSL ? 'https:' : 'http:') +         '//www.googletagservices.com/tag/js/gpt.js';     document.write('');   })(); Search:   Reference <unordered_set> unordered_set class template <unordered_set> std::unordered_set template < class Key,                        // unordered_set::key_type/value_type           class Hash = hash<Key>,           // unordered_set::hasher           class Pred = equal_to<Key>,       // unordered_set::key_equal           class Alloc = allocator<Key>      // unordered_set::allocator_type           > class unordered_set;Unordered Set Unordered sets are containers that store unique elements in no particular order, and which allow for fast retrieval of individual elements based on their value.    In an unordered_set, the value of an element is at the same time its key, that identifies it uniquely. Keys are immutable, therefore, the elements in an unordered_set cannot be modified once in the container - they can be inserted and removed, though.    Internally, the elements in the unordered_set are not sorted in any particular order, but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their values (with a constant average time complexity on average).    unordered_set containers are faster than set containers to access individual elements by their key, although they are generally less efficient for range iteration through a subset of their elements.    Iterators in the container are at least forward iterators.    Container properties Associative Elements in associative containers are referenced by their key and not by their absolute position in the container. Unordered Unordered containers organize their elements using hash tables that allow for fast access to elements by their key. Set The value of an element is also the key used to identify it. Unique keys No two elements in the container can have equivalent keys. Allocator-aware The container uses an allocator object to dynamically handle its storage needs.   Template parameters Key Type of the elements. Each element in an unordered_set is also uniquely identified by this value.  Aliased as member types unordered_set::key_type and unordered_set::value_type. Hash A unary function object type that takes an object of the same type as the elements as argument and returns a unique value of type size_t based on it. This can either be a class implementing a function call operator or a pointer to a function (see constructor for an example). This defaults to hash<Key>, which returns a hash value with a probability of collision approaching 1.0/std::numeric_limits<size_t>::max().  The unordered_set object uses the hash values returned by this function to organize its elements internally, speeding up the process of locating individual elements.  Aliased as member type unordered_set::hasher. Pred A binary predicate that takes two arguments of the same type as the elements and returns a bool. The expression pred(a,b), where pred is an object of this type and a and b are key values, shall return true if a is to be considered equivalent to b. This can either be a class implementing a function call operator or a pointer to a function (see constructor for an example). This defaults to equal_to<Key>, which returns the same as applying the equal-to operator (a==b).  The unordered_set object uses this expression to determine whether two element keys are equivalent. No two elements in an unordered_set container can have keys that yield true using this predicate.  Aliased as member type unordered_set::key_equal. Alloc Type of the allocator object used to define the storage allocation model. By default, the allocator class template is used, which defines the simplest memory allocation model and is value-independent.  Aliased as member type unordered_set::allocator_type.   In the reference for the unordered_set member functions, these same names (Key, Hash, Pred and Alloc) are assumed for the template parameters.    Member types The following aliases are member types of unordered_set. They are widely used as parameter and return types by member functions:    member typedefinitionnotes key_typethe first template parameter (Key) value_typethe first template parameter (Key)The same as key_type hasherthe second template parameter (Hash)defaults to: hash<key_type> key_equalthe third template parameter (Pred)defaults to: equal_to<key_type> allocator_typethe fourth template parameter (Alloc)defaults to: allocator<value_type> referenceAlloc::reference const_referenceAlloc::const_reference pointerAlloc::pointerfor the default allocator: value_type* const_pointerAlloc::const_pointerfor the default allocator: const value_type* iteratora forward iterator to const value_type* convertible to const_iterator const_iteratora forward iterator to const value_type* local_iteratora forward iterator to const value_type* convertible to const_local_iterator const_local_iteratora forward iterator to const value_type* size_typean unsigned integral typeusually the same as size_t difference_typea signed integral typeusually the same as ptrdiff_t member typedefinitionnotes key_typethe first template parameter (Key) value_typethe first template parameter (Key)The same as key_type hasherthe second template parameter (Hash)defaults to: hash<key_type> key_equalthe third template parameter (Pred)defaults to: equal_to<key_type> allocator_typethe fourth template parameter (Alloc)defaults to: allocator<value_type> referencevalue_type& const_referenceconst value_type& pointerallocator_traits<Alloc>::pointerfor the default allocator: value_type* const_pointerallocator_traits<Alloc>::const_pointerfor the default allocator: const value_type* iteratora forward iterator to const value_type* convertible to const_iterator const_iteratora forward iterator to const value_type* local_iteratora forward iterator to const value_type* convertible to const_local_iterator const_local_iteratora forward iterator to const value_type* size_typean unsigned integral typeusually the same as size_t difference_typea signed integral typeusually the same as ptrdiff_t *Note: All iterators in an unordered_set point to const elements. Whether the const_ member type is the same type as its non-const_ counterpart depends on the particular library implementation, but programs should not rely on them being different to overload functions: const_iterator is more generic, since iterator is always convertible to it.  The same applies to local_ and non-local_ iterator types: they may either be the same type or not, but a program should not rely on them being different.    Member functions (constructor)Construct unordered_set (public member function)(destructor)Destroy unordered set (public member function)operator=Assign content (public member function)   Capacity emptyTest whether container is empty (public member function)sizeReturn container size (public member function)max_sizeReturn maximum size (public member function)   Iterators beginReturn iterator to beginning (public member type)endReturn iterator to end (public member type)cbeginReturn const_iterator to beginning (public member function)cendReturn const_iterator to end (public member function)   Element lookup findGet iterator to element (public member function)countCount elements with a specific key (public member function)equal_rangeGet range of elements with a specific key (public member function)   Modifiers emplaceConstruct and insert element (public member function)emplace_hintConstruct and insert element with hint (public member function)insertInsert elements (public member function)eraseErase elements (public member function)clearClear content (public member function)swapSwap content (public member function)   Buckets bucket_countReturn number of buckets (public member function)max_bucket_countReturn maximum number of buckets (public member function)bucket_sizeReturn bucket size (public member type)bucketLocate element's bucket (public member function)   Hash policy load_factorReturn load factor (public member function)max_load_factorGet or set maximum load factor (public member function)rehashSet number of buckets (public member function)reserveRequest a capacity change (public member function)   Observers hash_functionGet hash function (public member type)key_eqGet key equivalence predicate (public member type)get_allocatorGet allocator (public member function)   Non-member function overloads operators (unordered_set)Relational operators for unordered_set (function template)swap (unordered_set)Exchanges contents of two unordered_set containers (function template) C++ Information Tutorials Reference Articles Forum Reference C library: <cassert> (assert.h) <cctype> (ctype.h) <cerrno> (errno.h) <cfenv> (fenv.h) <cfloat> (float.h) <cinttypes> (inttypes.h) <ciso646> (iso646.h) <climits> (limits.h) <clocale> (locale.h) <cmath> (math.h) <csetjmp> (setjmp.h) <csignal> (signal.h) <cstdarg> (stdarg.h) <cstdbool> (stdbool.h) <cstddef> (stddef.h) <cstdint> (stdint.h) <cstdio> (stdio.h) <cstdlib> (stdlib.h) <cstring> (string.h) <ctgmath> (tgmath.h) <ctime> (time.h) <cuchar> (uchar.h) <cwchar> (wchar.h) <cwctype> (wctype.h) Containers: <array> <deque> <forward_list> <list> <map> <queue> <set> <stack> <unordered_map> <unordered_set> <vector> Input/Output: <fstream> <iomanip> <ios> <iosfwd> <iostream> <istream> <ostream> <sstream> <streambuf> Multi-threading: <atomic> <condition_variable> <future> <mutex> <thread> Other: <algorithm> <bitset> <chrono> <codecvt> <complex> <exception> <functional> <initializer_list> <iterator> <limits> <locale> <memory> <new> <numeric> <random> <ratio> <regex> <stdexcept> <string> <system_error> <tuple> <typeindex> <typeinfo> <type_traits> <utility> <valarray> <unordered_set> unordered_multiset unordered_set unordered_set unordered_set::unordered_set unordered_set::~unordered_set member functions: unordered_set::begin unordered_set::bucket unordered_set::bucket_count unordered_set::bucket_size unordered_set::cbegin unordered_set::cend unordered_set::clear unordered_set::count unordered_set::emplace unordered_set::emplace_hint unordered_set::empty unordered_set::end unordered_set::equal_range unordered_set::erase unordered_set::find unordered_set::get_allocator unordered_set::hash_function unordered_set::insert unordered_set::key_eq unordered_set::load_factor unordered_set::max_bucket_count unordered_set::max_load_factor unordered_set::max_size unordered_set::operator= unordered_set::rehash unordered_set::reserve unordered_set::size unordered_set::swap non-member overloads: operators (unordered_set) swap (unordered_set) 			 	Home page | Privacy policy  cplusplus.com, 2000-2017 - All rights reserved - v3.1 Spotted an error? contact us (function(){   // mini cookie-consent code (c) Juan Soulie, 2016   var s ='consent=cookie';   var e = document.createElement('div');   e.innerHTML = 'This website uses cookies. By continuing, you give permission to deploy cookies, as detailed in our privacy policy. ok';   if (document.cookie.indexOf(s)!==-1) return;   var b = document.getElementsByTagName('body')[0];   b.insertBefore(e,b.firstChild);   var x = function() { document.cookie = s+'; path=/'; e.parentNode.removeChild(e); };   e.addEventListener('click',x);   document.addEventListener('scroll',x); })(); 
http://www.cplusplus.com/reference/unordered_set/unordered_multiset/index.htmlunordered_multiset unordered_multiset - C++ Reference   (function() {     var useSSL = 'https:' == document.location.protocol;     var src = (useSSL ? 'https:' : 'http:') +         '//www.googletagservices.com/tag/js/gpt.js';     document.write('');   })(); Search:   Reference <unordered_set> unordered_multiset class template <unordered_set> std::unordered_multiset template < class Key,                         // unordered_multiset::key_type/value_type           class Hash = hash<Key>,            // unordered_multiset::hasher           class Pred = equal_to<Key>,        // unordered_multiset::key_equal           class Alloc = allocator<Key>       // unordered_multiset::allocator_type           > class unordered_multiset;Unordered Multiset Unordered multisets are containers that store elements in no particular order, allowing fast retrieval of individual elements based on their value, much like unordered_set containers, but allowing different elements to have equivalent values.    In an unordered_multiset, the value of an element is at the same time its key, used to identify it. Keys are immutable, therefore, the elements in an unordered_multiset cannot be modified once in the container - they can be inserted and removed, though.    Internally, the elements in the unordered_multiset are not sorted in any particular, but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their values (with a constant average time complexity on average).    Elements with equivalent values are grouped together in the same bucket and in such a way that an iterator (see equal_range) can iterate through all of them.    Iterators in the container are at least forward iterators.    Notice that this container is not defined in its own header, but shares header <unordered_set> with unordered_set.    Container properties Associative Elements in associative containers are referenced by their key and not by their absolute position in the container. Unordered Unordered containers organize their elements using hash tables that allow for fast access to elements by their key. Set The value of an element is also the key used to identify it. Multiple equivalent keys The container can hold multiple elements with equivalent keys. Allocator-aware The container uses an allocator object to dynamically handle its storage needs.   Template parameters Key Type of the elements. Each element in an unordered_multiset is also  identified by this value.  Aliased as member types unordered_multiset::key_type and unordered_multiset::value_type. Hash A unary function object type that takes an object of the same type as the elements as argument and returns a unique value of type size_t based on it. This can either be a class implementing a function call operator or a pointer to a function (see constructor for an example). This defaults to hash<Key>, which returns a hash value with a probability of collision approaching 1.0/std::numeric_limits<size_t>::max().  The unordered_multiset object uses the hash values returned by this function to organize its elements internally, speeding up the process of locating individual elements.  Aliased as member type unordered_multiset::hasher. Pred A binary predicate that takes two arguments of the same type as the elements and returns a bool. The expression pred(a,b), where pred is an object of this type and a and b are key values, shall return true if a is to be considered equivalent to b. This can either be a class implementing a function call operator or a pointer to a function (see constructor for an example). This defaults to equal_to<Key>, which returns the same as applying the equal-to operator (a==b).  The unordered_multiset object uses this expression to determine whether two element keys are equivalent. This container supports multiple elements with equivalent keys.  Aliased as member type unordered_multiset::key_equal. Alloc Type of the allocator object used to define the storage allocation model. By default, the allocator class template is used, which defines the simplest memory allocation model and is value-independent.  Aliased as member type unordered_multiset::allocator_type.   In the reference for the unordered_multiset member functions, these same names (Key, Hash, Pred and Alloc) are assumed for the template parameters.    Member types The following aliases are member types of unordered_multiset. They are widely used as parameter and return types by member functions:    member typedefinitionnotes key_typethe first template parameter (Key) value_typethe first template parameter (Key)The same as key_type hasherthe second template parameter (Hash)defaults to: hash<key_type> key_equalthe third template parameter (Pred)defaults to: equal_to<key_type> allocator_typethe fourth template parameter (Alloc)defaults to: allocator<value_type> referenceAlloc::reference const_referenceAlloc::const_reference pointerAlloc::pointerfor the default allocator: value_type* const_pointerAlloc::const_pointerfor the default allocator: const value_type* iteratora forward iterator to const value_type* convertible to const_iterator const_iteratora forward iterator to const value_type* local_iteratora forward iterator to const value_type* convertible to const_local_iterator const_local_iteratora forward iterator to const value_type* size_typean unsigned integral typeusually the same as size_t difference_typea signed integral typeusually the same as ptrdiff_t member typedefinitionnotes key_typethe first template parameter (Key) value_typethe first template parameter (Key)The same as key_type hasherthe second template parameter (Hash)defaults to: hash<key_type> key_equalthe third template parameter (Pred)defaults to: equal_to<key_type> allocator_typethe fourth template parameter (Alloc)defaults to: allocator<value_type> referencevalue_type& const_referenceconst value_type& pointerallocator_traits<Alloc>::pointerfor the default allocator: value_type* const_pointerallocator_traits<Alloc>::const_pointerfor the default allocator: const value_type* iteratora forward iterator to const value_type* convertible to const_iterator const_iteratora forward iterator to const value_type* local_iteratora forward iterator to const value_type* convertible to const_local_iterator const_local_iteratora forward iterator to const value_type* size_typean unsigned integral typeusually the same as size_t difference_typea signed integral typeusually the same as ptrdiff_t *Note: All iterators in a unordered_multiset point to const elements. Whether the const_ member type is the same type as its non-const_ counterpart depends on the particular library implementation, but programs should not rely on them being different to overload functions: const_iterator is more generic, since iterator is always convertible to it.  The same applies to local_ and non-local_ iterator types: they may either be the same type or not, but a program should not rely on them being different.    Member functions (constructor)Construct unordered_multiset (public member function)(destructor)Destroy unordered multiset (public member function)operator=Assign content (public member function)   Capacity emptyTest whether container is empty (public member function)sizeReturn container size (public member function)max_sizeReturn maximum size (public member function)   Iterators beginReturn iterator to beginning (public member type)endReturn iterator to end (public member type)cbeginReturn const_iterator to beginning (public member type)cendReturn const_iterator to end (public member type)   Element lookup findGet iterator to element (public member function)countCount elements with a specific key (public member function)equal_rangeGet range of elements with specific key (public member function)   Modifiers emplaceConstruct and insert element (public member function)emplace_hintConstruct and insert element with hint (public member function)insertInsert elements (public member function)eraseErase elements (public member function)clearClear content (public member function)swapSwap content (public member function)   Buckets bucket_countReturn number of buckets (public member function)max_bucket_countReturn maximum number of buckets (public member function)bucket_sizeReturn bucket size (public member type)bucketLocate element's bucket (public member function)   Hash policy load_factorReturn load factor (public member function)max_load_factorGet or set maximum load factor (public member function)rehashSet number of buckets (public member function)reserveRequest a capacity change (public member function)   Observers hash_functionGet hash function (public member type)key_eqGet key equivalence predicate (public member type)get_allocatorGet allocator (public member function)   Non-member function overloads operators (unordered_multiset)Relational operators for unordered_multiset (function template)swap (unordered_multiset)Exchanges contents of two unordered_multiset containers (function template) C++ Information Tutorials Reference Articles Forum Reference C library: <cassert> (assert.h) <cctype> (ctype.h) <cerrno> (errno.h) <cfenv> (fenv.h) <cfloat> (float.h) <cinttypes> (inttypes.h) <ciso646> (iso646.h) <climits> (limits.h) <clocale> (locale.h) <cmath> (math.h) <csetjmp> (setjmp.h) <csignal> (signal.h) <cstdarg> (stdarg.h) <cstdbool> (stdbool.h) <cstddef> (stddef.h) <cstdint> (stdint.h) <cstdio> (stdio.h) <cstdlib> (stdlib.h) <cstring> (string.h) <ctgmath> (tgmath.h) <ctime> (time.h) <cuchar> (uchar.h) <cwchar> (wchar.h) <cwctype> (wctype.h) Containers: <array> <deque> <forward_list> <list> <map> <queue> <set> <stack> <unordered_map> <unordered_set> <vector> Input/Output: <fstream> <iomanip> <ios> <iosfwd> <iostream> <istream> <ostream> <sstream> <streambuf> Multi-threading: <atomic> <condition_variable> <future> <mutex> <thread> Other: <algorithm> <bitset> <chrono> <codecvt> <complex> <exception> <functional> <initializer_list> <iterator> <limits> <locale> <memory> <new> <numeric> <random> <ratio> <regex> <stdexcept> <string> <system_error> <tuple> <typeindex> <typeinfo> <type_traits> <utility> <valarray> <unordered_set> unordered_multiset unordered_set unordered_multiset unordered_multiset::unordered_multiset unordered_multiset::~unordered_multiset member functions: unordered_multiset::begin unordered_multiset::bucket unordered_multiset::bucket_count unordered_multiset::bucket_size unordered_multiset::cbegin unordered_multiset::cend unordered_multiset::clear unordered_multiset::count unordered_multiset::emplace unordered_multiset::emplace_hint unordered_multiset::empty unordered_multiset::end unordered_multiset::equal_range unordered_multiset::erase unordered_multiset::find unordered_multiset::get_allocator unordered_multiset::hash_function unordered_multiset::insert unordered_multiset::key_eq unordered_multiset::load_factor unordered_multiset::max_bucket_count unordered_multiset::max_load_factor unordered_multiset::max_size unordered_multiset::operator= unordered_multiset::rehash unordered_multiset::reserve unordered_multiset::size unordered_multiset::swap non-member overloads: operators (unordered_multiset) swap (unordered_multiset) 			 	Home page | Privacy policy  cplusplus.com, 2000-2017 - All rights reserved - v3.1 Spotted an error? contact us (function(){   // mini cookie-consent code (c) Juan Soulie, 2016   var s ='consent=cookie';   var e = document.createElement('div');   e.innerHTML = 'This website uses cookies. By continuing, you give permission to deploy cookies, as detailed in our privacy policy. ok';   if (document.cookie.indexOf(s)!==-1) return;   var b = document.getElementsByTagName('body')[0];   b.insertBefore(e,b.firstChild);   var x = function() { document.cookie = s+'; path=/'; e.parentNode.removeChild(e); };   e.addEventListener('click',x);   document.addEventListener('scroll',x); })(); 
http://www.cplusplus.com/reference/unordered_map/unordered_map/index.htmlunordered_map unordered_map - C++ Reference   (function() {     var useSSL = 'https:' == document.location.protocol;     var src = (useSSL ? 'https:' : 'http:') +         '//www.googletagservices.com/tag/js/gpt.js';     document.write('');   })(); Search:   Reference <unordered_map> unordered_map class template <unordered_map> std::unordered_map template < class Key,                                    // unordered_map::key_type           class T,                                      // unordered_map::mapped_type           class Hash = hash<Key>,                       // unordered_map::hasher           class Pred = equal_to<Key>,                   // unordered_map::key_equal           class Alloc = allocator< pair<const Key,T> >  // unordered_map::allocator_type           > class unordered_map;Unordered Map Unordered maps are associative containers that store elements formed by the combination of a key value and a mapped value, and which allows for fast retrieval of individual elements based on their keys.    In an unordered_map, the key value is generally used to uniquely identify the element, while the mapped value is an object with the content associated to this key. Types of key and mapped value may differ.    Internally, the elements in the unordered_map are not sorted in any particular order with respect to either their key or mapped values, but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their key values (with a constant average time complexity on average).    unordered_map containers are faster than map containers to access individual elements by their key, although they are generally less efficient for range iteration through a subset of their elements.    Unordered maps implement the direct access operator (operator[]) which allows for direct access of the mapped value using its key value as argument.    Iterators in the container are at least forward iterators.    Container properties Associative Elements in associative containers are referenced by their key and not by their absolute position in the container. Unordered Unordered containers organize their elements using hash tables that allow for fast access to elements by their key. Map Each element associates a key to a mapped value: Keys are meant to identify the elements whose main content is the mapped value. Unique keys No two elements in the container can have equivalent keys. Allocator-aware The container uses an allocator object to dynamically handle its storage needs.   Template parameters Key Type of the key values. Each element in an unordered_map is uniquely identified by its key value.  Aliased as member type unordered_map::key_type. T Type of the mapped value. Each element in an unordered_map is used to store some data as its mapped value.  Aliased as member type unordered_map::mapped_type. Note that this is not the same as unordered_map::value_type (see below). Hash A unary function object type that takes an object of type key type as argument and returns a unique value of type size_t based on it. This can either be a class implementing a function call operator or a pointer to a function (see constructor for an example). This defaults to hash<Key>, which returns a hash value with a probability of collision approaching 1.0/std::numeric_limits<size_t>::max().  The unordered_map object uses the hash values returned by this function to organize its elements internally, speeding up the process of locating individual elements.  Aliased as member type unordered_map::hasher. Pred A binary predicate that takes two arguments of the key type and returns a bool. The expression pred(a,b), where pred is an object of this type and a and b are key values, shall return true if a is to be considered equivalent to b. This can either be a class implementing a function call operator or a pointer to a function (see constructor for an example). This defaults to equal_to<Key>, which returns the same as applying the equal-to operator (a==b).  The unordered_map object uses this expression to determine whether two element keys are equivalent. No two elements in an unordered_map container can have keys that yield true using this predicate.  Aliased as member type unordered_map::key_equal. Alloc Type of the allocator object used to define the storage allocation model. By default, the allocator class template is used, which defines the simplest memory allocation model and is value-independent.  Aliased as member type unordered_map::allocator_type.   In the reference for the unordered_map member functions, these same names (Key, T, Hash, Pred and Alloc) are assumed for the template parameters.    Iterators to elements of unordered_map containers access to both the key and the mapped value. For this, the class defines what is called its value_type, which is a pair class with its first value corresponding to the const version of the key type (template parameter Key) and its second value corresponding to the mapped value (template parameter T):    typedef pair<const Key, T> value_type;     Iterators of a unordered_map container point to elements of this value_type. Thus, for an iterator called it that points to an element of a map, its key and mapped value can be accessed respectively with:  1 2 3 4  unordered_map<Key,T>::iterator it; (*it).first;             // the key value (of type Key) (*it).second;            // the mapped value (of type T) (*it);                   // the "element value" (of type pair<const Key,T>)    Naturally, any other direct access operator, such as -> or [] can be used, for example:  1 2  it->first;               // same as (*it).first   (the key value) it->second;              // same as (*it).second  (the mapped value)      Member types The following aliases are member types of unordered_map. They are widely used as parameter and return types by member functions:    member typedefinitionnotes key_typethe first template parameter (Key) mapped_typethe second template parameter (T) value_typepair<const key_type,mapped_type> hasherthe third template parameter (Hash)defaults to: hash<key_type> key_equalthe fourth template parameter (Pred)defaults to: equal_to<key_type> allocator_typethe fifth template parameter (Alloc)defaults to: allocator<value_type> referenceAlloc::reference const_referenceAlloc::const_reference pointerAlloc::pointerfor the default allocator: value_type* const_pointerAlloc::const_pointerfor the default allocator: const value_type* iteratora forward iterator to value_type const_iteratora forward iterator to const value_type local_iteratora forward iterator to value_type const_local_iteratora forward iterator to const value_type size_typean unsigned integral typeusually the same as size_t difference_typea signed integral typeusually the same as ptrdiff_t member typedefinitionnotes key_typethe first template parameter (Key) mapped_typethe second template parameter (T) value_typepair<const key_type,mapped_type> hasherthe third template parameter (Hash)defaults to: hash<key_type> key_equalthe fourth template parameter (Pred)defaults to: equal_to<key_type> allocator_typethe fifth template parameter (Alloc)defaults to: allocator<value_type> referencevalue_type& const_referenceconst value_type& pointerallocator_traits<Alloc>::pointerfor the default allocator: value_type* const_pointerallocator_traits<Alloc>::const_pointerfor the default allocator: const value_type* iteratora forward iterator to value_type const_iteratora forward iterator to const value_type local_iteratora forward iterator to value_type const_local_iteratora forward iterator to const value_type size_typean unsigned integral typeusually the same as size_t difference_typea signed integral typeusually the same as ptrdiff_t   Member functions (constructor)Construct unordered_map (public member function)(destructor)Destroy unordered map (public member function)operator=Assign content (public member function)   Capacity emptyTest whether container is empty (public member function)sizeReturn container size (public member function)max_sizeReturn maximum size (public member function)   Iterators beginReturn iterator to beginning (public member function)endReturn iterator to end (public member function)cbeginReturn const_iterator to beginning (public member function)cendReturn const_iterator to end (public member function)   Element access operator[]Access element (public member function)atAccess element (public member function)   Element lookup findGet iterator to element (public member function)countCount elements with a specific key (public member function)equal_rangeGet range of elements with specific key (public member function)   Modifiers emplaceConstruct and insert element (public member function)emplace_hintConstruct and insert element with hint (public member function)insertInsert elements (public member function)eraseErase elements (public member function)clearClear content (public member function)swapSwap content (public member function)   Buckets bucket_countReturn number of buckets (public member function)max_bucket_countReturn maximum number of buckets (public member function)bucket_sizeReturn bucket size (public member type)bucketLocate element's bucket (public member function)   Hash policy load_factorReturn load factor (public member function)max_load_factorGet or set maximum load factor (public member function)rehashSet number of buckets (public member function)reserveRequest a capacity change (public member function)   Observers hash_functionGet hash function (public member type)key_eqGet key equivalence predicate (public member type)get_allocatorGet allocator (public member function)   Non-member function overloads operators (unordered_map)Relational operators for unordered_map (function template)swap (unordered_map)Exchanges contents of two unordered_map containers (function template) C++ Information Tutorials Reference Articles Forum Reference C library: <cassert> (assert.h) <cctype> (ctype.h) <cerrno> (errno.h) <cfenv> (fenv.h) <cfloat> (float.h) <cinttypes> (inttypes.h) <ciso646> (iso646.h) <climits> (limits.h) <clocale> (locale.h) <cmath> (math.h) <csetjmp> (setjmp.h) <csignal> (signal.h) <cstdarg> (stdarg.h) <cstdbool> (stdbool.h) <cstddef> (stddef.h) <cstdint> (stdint.h) <cstdio> (stdio.h) <cstdlib> (stdlib.h) <cstring> (string.h) <ctgmath> (tgmath.h) <ctime> (time.h) <cuchar> (uchar.h) <cwchar> (wchar.h) <cwctype> (wctype.h) Containers: <array> <deque> <forward_list> <list> <map> <queue> <set> <stack> <unordered_map> <unordered_set> <vector> Input/Output: <fstream> <iomanip> <ios> <iosfwd> <iostream> <istream> <ostream> <sstream> <streambuf> Multi-threading: <atomic> <condition_variable> <future> <mutex> <thread> Other: <algorithm> <bitset> <chrono> <codecvt> <complex> <exception> <functional> <initializer_list> <iterator> <limits> <locale> <memory> <new> <numeric> <random> <ratio> <regex> <stdexcept> <string> <system_error> <tuple> <typeindex> <typeinfo> <type_traits> <utility> <valarray> <unordered_map> unordered_map unordered_multimap unordered_map unordered_map::unordered_map unordered_map::~unordered_map member functions: unordered_map::at unordered_map::begin unordered_map::bucket unordered_map::bucket_count unordered_map::bucket_size unordered_map::cbegin unordered_map::cend unordered_map::clear unordered_map::count unordered_map::emplace unordered_map::emplace_hint unordered_map::empty unordered_map::end unordered_map::equal_range unordered_map::erase unordered_map::find unordered_map::get_allocator unordered_map::hash_function unordered_map::insert unordered_map::key_eq unordered_map::load_factor unordered_map::max_bucket_count unordered_map::max_load_factor unordered_map::max_size unordered_map::operator= unordered_map::operator[] unordered_map::rehash unordered_map::reserve unordered_map::size unordered_map::swap non-member overloads: operators (unordered_map) swap (unordered_map) 			 	Home page | Privacy policy  cplusplus.com, 2000-2017 - All rights reserved - v3.1 Spotted an error? contact us (function(){   // mini cookie-consent code (c) Juan Soulie, 2016   var s ='consent=cookie';   var e = document.createElement('div');   e.innerHTML = 'This website uses cookies. By continuing, you give permission to deploy cookies, as detailed in our privacy policy. ok';   if (document.cookie.indexOf(s)!==-1) return;   var b = document.getElementsByTagName('body')[0];   b.insertBefore(e,b.firstChild);   var x = function() { document.cookie = s+'; path=/'; e.parentNode.removeChild(e); };   e.addEventListener('click',x);   document.addEventListener('scroll',x); })(); 
http://www.cplusplus.com/reference/unordered_map/unordered_multimap/index.htmlunordered_multimap unordered_multimap - C++ Reference   (function() {     var useSSL = 'https:' == document.location.protocol;     var src = (useSSL ? 'https:' : 'http:') +         '//www.googletagservices.com/tag/js/gpt.js';     document.write('');   })(); Search:   Reference <unordered_map> unordered_multimap class template <unordered_map> std::unordered_multimap template < class Key,                                    // unordered_multimap::key_type           class T,                                      // unordered_multimap::mapped_type           class Hash = hash<Key>,                       // unordered_multimap::hasher           class Pred = equal_to<Key>,                   // unordered_multimap::key_equal           class Alloc = allocator< pair<const Key,T> >  // unordered_multimap::allocator_type           > class unordered_multimap;Unordered Multimap Unordered multimaps are associative containers that store elements formed by the combination of a key value and a mapped value, much like unordered_map containers, but allowing different elements to have equivalent keys.    In an unordered_multimap, the key value is generally used to uniquely identify the element, while the mapped value is an object with the content associated to this key. Types of key and mapped value may differ.    Internally, the elements in the unordered_multimap are not sorted in any particular order with respect to either their key or mapped values, but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their key values (with a constant average time complexity on average).    Elements with equivalent keys are grouped together in the same bucket and in such a way that an iterator (see equal_range) can iterate through all of them.    Iterators in the container are at least forward iterators.    Notice that this container is not defined in its own header, but shares header <unordered_map> with unordered_map.    Container properties Associative Elements in associative containers are referenced by their key and not by their absolute position in the container. Unordered Unordered containers organize their elements using hash tables that allow for fast access to elements by their key. Map Each element associates a key to a mapped value: Keys are meant to identify the elements whose main content is the mapped value. Multiple equivalent keys The container can hold multiple elements with equivalent keys. Allocator-aware The container uses an allocator object to dynamically handle its storage needs.   Template parameters Key Type of the key values. Each element in an unordered_multimap is identified by a key value.  Aliased as member type unordered_multimap::key_type. T Type of the mapped value. Each element in an unordered_multimap is used to store some data as its mapped value.  Aliased as member type unordered_multimap::mapped_type. Note that this is not the same as unordered_multimap::value_type (see below). Hash A unary function object type that takes an object of type key type as argument and returns a unique value of type size_t based on it. This can either be a class implementing a function call operator or a pointer to a function (see constructor for an example). This defaults to hash<Key>, which returns a hash value with a probability of collision approaching 1.0/std::numeric_limits<size_t>::max().  The unordered_multimap object uses the hash values returned by this function to organize its elements internally, speeding up the process of locating individual elements.  Aliased as member type unordered_multimap::hasher. Pred A binary predicate that takes two arguments of the key type and returns a bool. The expression pred(a,b), where pred is an object of this type and a and b are key values, shall return true if a is to be considered equivalent to b. This can either be a class implementing a function call operator or a pointer to a function (see constructor for an example). This defaults to equal_to<Key>, which returns the same as applying the equal-to operator (a==b).  The unordered_multimap object uses this expression to determine whether two element keys are equivalent. This container supports multiple elements with equivalent keys.  Aliased as member type unordered_multimap::key_equal. Alloc Type of the allocator object used to define the storage allocation model. By default, the allocator class template is used, which defines the simplest memory allocation model and is value-independent.  Aliased as member type unordered_multimap::allocator_type.   In the reference for the unordered_multimap member functions, these same names (Key, T, Hash, Pred and Alloc) are assumed for the template parameters.    Member types The following aliases are member types of unordered_multimap. They are widely used as parameter and return types by member functions:    member typedefinitionnotes key_typethe first template parameter (Key) mapped_typethe second template parameter (T) value_typepair<const key_type,mapped_type> hasherthe third template parameter (Hash)defaults to: hash<key_type> key_equalthe fourth template parameter (Pred)defaults to: equal_to<key_type> allocator_typethe fifth template parameter (Alloc)defaults to: allocator<value_type> referenceAlloc::reference const_referenceAlloc::const_reference pointerAlloc::pointerfor the default allocator: value_type* const_pointerAlloc::const_pointerfor the default allocator: const value_type* iteratora forward iterator to value_typeconvertible to const_iterator const_iteratora forward iterator to const value_type local_iteratora forward iterator to value_typeconvertible to const_local_iterator const_local_iteratora forward iterator to const value_type size_typean unsigned integral typeusually the same as size_t difference_typea signed integral typeusually the same as ptrdiff_t member typedefinitionnotes key_typethe first template parameter (Key) mapped_typethe second template parameter (T) value_typepair<const key_type,mapped_type> hasherthe third template parameter (Hash)defaults to: hash<key_type> key_equalthe fourth template parameter (Pred)defaults to: equal_to<key_type> allocator_typethe fifth template parameter (Alloc)defaults to: allocator<value_type> referencevalue_type& const_referenceconst value_type& pointerallocator_traits<Alloc>::pointerfor the default allocator: value_type* const_pointerallocator_traits<Alloc>::const_pointerfor the default allocator: const value_type* iteratora forward iterator to value_typeconvertible to const_iterator const_iteratora forward iterator to const value_type local_iteratora forward iterator to value_typeconvertible to const_local_iterator const_local_iteratora forward iterator to const value_type size_typean unsigned integral typeusually the same as size_t difference_typea signed integral typeusually the same as ptrdiff_t   Member functions (constructor)Construct unordered_multimap (public member function)(destructor)Destroy unordered multimap (public member function)operator=Assign content (public member function)   Capacity emptyTest whether container is empty (public member function)sizeReturn container size (public member function)max_sizeReturn maximum size (public member function)   Iterators beginReturn iterator to beginning (public member type)endReturn iterator to end (public member type)cbeginReturn const_iterator to beginning (public member function)cendReturn const_iterator to end (public member function)   Element lookup findGet iterator to element (public member function)countCount elements with a specific key (public member function)equal_rangeGet range of elements with specific key (public member function)   Modifiers emplaceConstruct and insert element (public member function)emplace_hintConstruct and insert element with hint (public member function)insertInsert elements (public member function)eraseErase elements (public member function)clearClear content (public member function)swapSwap content (public member function)   Buckets bucket_countReturn number of buckets (public member function)max_bucket_countReturn maximum number of buckets (public member function)bucket_sizeReturn bucket_size (public member type)bucketLocate element's bucket (public member function)   Hash policy load_factorReturn load factor (public member function)max_load_factorGet or set maximum load factor (public member function)rehashSet number of buckets (public member function)reserveRequest a capacity change (public member function)   Observers hash_functionGet hash function (public member type)key_eqGet key equivalence predicate (public member type)get_allocatorGet allocator (public member function)   Non-member function overloads operators (unordered_multimap)Relational operators for unordered_multimap (function template)swap (unordered_multimap)Exchanges contents of two unordered_multimap containers (function template) C++ Information Tutorials Reference Articles Forum Reference C library: <cassert> (assert.h) <cctype> (ctype.h) <cerrno> (errno.h) <cfenv> (fenv.h) <cfloat> (float.h) <cinttypes> (inttypes.h) <ciso646> (iso646.h) <climits> (limits.h) <clocale> (locale.h) <cmath> (math.h) <csetjmp> (setjmp.h) <csignal> (signal.h) <cstdarg> (stdarg.h) <cstdbool> (stdbool.h) <cstddef> (stddef.h) <cstdint> (stdint.h) <cstdio> (stdio.h) <cstdlib> (stdlib.h) <cstring> (string.h) <ctgmath> (tgmath.h) <ctime> (time.h) <cuchar> (uchar.h) <cwchar> (wchar.h) <cwctype> (wctype.h) Containers: <array> <deque> <forward_list> <list> <map> <queue> <set> <stack> <unordered_map> <unordered_set> <vector> Input/Output: <fstream> <iomanip> <ios> <iosfwd> <iostream> <istream> <ostream> <sstream> <streambuf> Multi-threading: <atomic> <condition_variable> <future> <mutex> <thread> Other: <algorithm> <bitset> <chrono> <codecvt> <complex> <exception> <functional> <initializer_list> <iterator> <limits> <locale> <memory> <new> <numeric> <random> <ratio> <regex> <stdexcept> <string> <system_error> <tuple> <typeindex> <typeinfo> <type_traits> <utility> <valarray> <unordered_map> unordered_map unordered_multimap unordered_multimap unordered_multimap::unordered_multimap unordered_multimap::~unordered_multimap member functions: unordered_multimap::begin unordered_multimap::bucket unordered_multimap::bucket_count unordered_multimap::bucket_size unordered_multimap::cbegin unordered_multimap::cend unordered_multimap::clear unordered_multimap::count unordered_multimap::emplace unordered_multimap::emplace_hint unordered_multimap::empty unordered_multimap::end unordered_multimap::equal_range unordered_multimap::erase unordered_multimap::find unordered_multimap::get_allocator unordered_multimap::hash_function unordered_multimap::insert unordered_multimap::key_eq unordered_multimap::load_factor unordered_multimap::max_bucket_count unordered_multimap::max_load_factor unordered_multimap::max_size unordered_multimap::operator= unordered_multimap::rehash unordered_multimap::reserve unordered_multimap::size unordered_multimap::swap non-member overloads: operators (unordered_multimap) swap (unordered_multimap) 			 	Home page | Privacy policy  cplusplus.com, 2000-2017 - All rights reserved - v3.1 Spotted an error? contact us (function(){   // mini cookie-consent code (c) Juan Soulie, 2016   var s ='consent=cookie';   var e = document.createElement('div');   e.innerHTML = 'This website uses cookies. By continuing, you give permission to deploy cookies, as detailed in our privacy policy. ok';   if (document.cookie.indexOf(s)!==-1) return;   var b = document.getElementsByTagName('body')[0];   b.insertBefore(e,b.firstChild);   var x = function() { document.cookie = s+'; path=/'; e.parentNode.removeChild(e); };   e.addEventListener('click',x);   document.addEventListener('scroll',x); })(); 
